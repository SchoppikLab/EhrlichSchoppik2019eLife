%Generate_ES19_from_Raw_Master
% By David E. Ehrlich, Sept. 10, 2019

% best to clear workspace before running 

%% Preprocess raw data by group
d_master = dir;
isub_master = [d_master(:).isdir]; %# returns logical vector
nameFolds_master = {d_master(isub_master).name}';

for groupFolderMaster=3:length(nameFolds_master)    
    cd(nameFolds_master{groupFolderMaster})
    
    d = dir;
    isub = [d(:).isdir]; %# returns logical vector
    nameFolds = {d(isub).name}';

    % Some parameters
    edge_size = 5; %number of samples to remove from the beginning and end of each vector to account for edge effects (improper detection of fish body as it leaves field of view)
    samplerate = 40; %in Hz
    speedThreshold = 5; %mm/s, speed threshold for identifying bouts

    % Initialize concatenating variables, described where filled
    %General variables
    BodyAngles = []; GrabbedTimes = [];
    TrajectoryMatchedAngles = []; TrajectoryMatchedTimes = []; TrajectoryMatchedSpeeds = []; 
    TrajectoryMatchedAngVels = []; AllTrajectory=[];

    %Output variables for propulsive bouts
    PropBoutTime = []; PropBoutDuration = []; PropBoutDisplacement = [];
    PropBoutMaxSpd = []; PropBoutMaxAngVel = []; PropBoutPeakAngVel = [];
    PropBoutIEI = []; PropBoutIEItime = []; PropBoutIEIpitch = []; 
    PropBoutIEIangVel = []; PropBoutIEIangAcc = [];
    PropBoutIEIalignedPitch{1} = []; PropBoutIEIalignedAngVel{1} = [];
    PropBoutIEIyDisplacement = []; PropBoutIEIyDisplacementTimes = [];
    PropBoutIEIyDisplacementMatchedIEIs = [];

    %Output variables aligned to peak translation of propulsive bout
    PropBoutAlignedTime = []; PropBoutAlignedPitch = []; PropBoutAlignedAngVel = [];
    PropBoutAlignedSpeed = []; PropBoutInitPitch = []; PropBoutNetPitchChg = []; 
    PropBoutAlignedHeading = [];

    % Iterate through folders corresponding to each clutch and incorporate into grouped analysis by age
    for clutchFolder=1:(length(nameFolds)-2)
        cd(nameFolds{clutchFolder+2})  

        %Run in folder containing *.dlm files generated by VerticalFish LabView file
        filenames = dir('*.dlm');
        hh = waitbar(0,['Analyzing Clutch ' num2str(clutchFolder)]);

        % Loop through each file
        for filenum=1:length(filenames)
            %Load raw data and pre-process to parse out epochs
            raw = dlmread(filenames(filenum).name);
            analyzed = Preprocess_LabView_output_ES19(raw,filenum);
            % Loop through each epoch of the pre-processed file
            for ind=1:length(analyzed) 
                epochDur = length(analyzed(ind).y); %duration of present epoch
                %Calculate swim speed for each frame using Pythagorean theorem with
                %horizontal and vertical translation velocities
                for z = 1:epochDur-1
                    swimSpeed(z) = sqrt((analyzed(ind).xvel(z))^2 + (analyzed(ind).yvel(z))^2);
                end
                % Smoothing angular velocity to de-noise               
                smoothedAngVel = smooth(analyzed(ind).angularVelocity, 3);

                % Concatenate values for each frame while cycling through each epoch 
                GrabbedTimes(end+1:end+length(analyzed(ind).absHours)) = analyzed(ind).absHours + analyzed(ind).absMins/60 + analyzed(ind).absSecs/3600; %time in hours
                BodyAngles(end+1:end+length(analyzed(ind).absOrientation)) = analyzed(ind).absOrientation;
                waitbar(((filenum-1)+(ind/length(analyzed)))/length(filenames),hh);

                % Identify swim bouts and store peak translation speed and rotation speed             
                clear SpdWindStart SpdWindEnd;
                %find local maxima for speed above SpeedThreshold
                if max(swimSpeed(1:end-1)) >= speedThreshold %if fish swims faster than threshold
                    %identify start and end of window when fish crosses threshold
                    k = 1;
                    SpdWindStart(1) = 1;
                    while SpdWindStart(k) < epochDur-1 %for entire epoch
                        %find bout window start
                        try SpdWindEnd(k); %if there is an end to epoch 'k', advance that end if still above threshold or start a new epoch
                            %added the subsequent 'try' statement in case the end point is past the swimSpeed length. there is surely a better way to do this, but for now this fixes the problem. 
                            try swimSpeed(SpdWindEnd(k));
                                if swimSpeed(SpdWindEnd(k)) >= speedThreshold %if we are still above threshold
                                    SpdWindEnd(k) = SpdWindEnd(k)+1;                %advance end of window
                                else
                                    k = k+1;                                      %start a new epoch
                                    SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                                end
                             catch
                                k = k+1;                                      %start a new epoch
                                SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                             end
                        catch %if there is no end to epoch 'k', advance start or make an end
                            if swimSpeed(SpdWindStart(k)) < speedThreshold %if start of window 'k' is below threshold
                                SpdWindStart(k) = SpdWindStart(k) + 1; %advance start of window 'k'
                            else
                                SpdWindEnd(k) = SpdWindStart(k)+1; %if start is above threshold, make an end for this threshold
                            end
                        end
                    end

                    %if the last value of SpdWindEnd exceeds the length of swimSpeed, set it equal to the length of swimSpeed
                    try swimSpeed(SpdWindEnd(end));
                    catch SpdWindEnd(end) = length(swimSpeed);
                    end

                    % Check if SpdWindStarts are realistically spaced to constitute separate bouts (> 100ms). 
                    % If not, combine the bouts by using the first SpdWindStart and second SpdWindEnd
                    % Note: manually capping detected frequency at 10Hz
                    windowFrame = 1;                
                    while windowFrame<length(SpdWindEnd)
                        if SpdWindStart(windowFrame+1) - SpdWindEnd(windowFrame) < (ceil(samplerate/10)) %if difference in samples is less than 100 ms
                            SpdWindEnd(windowFrame) = SpdWindEnd(windowFrame+1);
                            %delete at windowFrame+1 index
                            SpdWindStart(windowFrame+1) = [];
                            SpdWindEnd(windowFrame+1) = [];
                            windowFrame = windowFrame - 1;
                        end
                        windowFrame = windowFrame+1;
                    end

                    % Isolate and analyze bouts
                    BoutPairTicker = 0;
                    for l=1:length(SpdWindEnd)
                        %find index for peak speed of bout
                        swimBoutPeakIndex = SpdWindStart(l)-1+find(swimSpeed(SpdWindStart(l):SpdWindEnd(l))==max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)))); 
                        %define window for surrounding bout
                        boutWindowStart = swimBoutPeakIndex-ceil(0.3*samplerate);
                        boutWindowEnd = swimBoutPeakIndex+ceil(0.3*samplerate);
                        %keep within epoch
                        if boutWindowStart < 1; boutWindowStart = 1; end                
                        if boutWindowEnd > length(analyzed(ind).angularVelocity(1+edge_size:end-edge_size))-1+edge_size; boutWindowEnd = length(analyzed(ind).angularVelocity(1+edge_size:end-edge_size))-1+edge_size; end
                        %max translation speed
                        boutSwimSpdMax(l) = max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)));    
                        %calculate time of bout from hours, minutes, and seconds
                        boutPeakHour(l) = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                        %maximum angular velocity during bout
                        boutMaxAbsAngVel(l) = max(abs(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l))));
                        %duration and displacement of bout
                        PropBoutDuration(end+1) = (SpdWindEnd(l)-SpdWindStart(l))/samplerate; %duration above speed threshold (5 mm/sec) in seconds
                        PropBoutDisplacement(end+1) = sqrt((analyzed(ind).x(boutWindowEnd)-analyzed(ind).x(boutWindowStart))^2+(analyzed(ind).y(boutWindowEnd)-analyzed(ind).y(boutWindowStart))^2);

                        %calculate peak angular velocity of this bout (largest magnitude, nose-up or -down)
                        if abs(min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))) > max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))
                            boutPeakAngVel(l) = min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                        else boutPeakAngVel(l) = max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                        end

                        % Record bout data aligned to propulsive peak
                        %if window is far enough from edge to allow alignment
                        %AND values during pre and post peak window are sufficiently low
                        if swimBoutPeakIndex > 30 && swimBoutPeakIndex < length(analyzed(ind).angularVelocity)-20 && min(swimSpeed(swimBoutPeakIndex-10:swimBoutPeakIndex)) < 3 && min(swimSpeed(swimBoutPeakIndex:boutWindowEnd)) < 3
                            boutAlign(l) = swimBoutPeakIndex;
                            PropBoutAlignedAngVel(end+1,1:51) = smoothedAngVel(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutAlignedSpeed(end+1,1:51) = swimSpeed(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutAlignedPitch(end+1,1:51) = analyzed(ind).absOrientation(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutInitPitch(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)-10:boutAlign(l)-5));
                            PropBoutNetPitchChg(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)+5:boutAlign(l)+10)) - PropBoutInitPitch(end);
                            AlignedTime = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                            PropBoutAlignedTime(end+1) = AlignedTime - floor(AlignedTime/24)*24; %time in hours for light/dark comparison

                            %Trajectory
                            clear pointed U_D R_L
                            tmp_y_vel = smooth(diff(analyzed(ind).y(boutAlign(l)-30:boutAlign(l)+21)),3);
                            tmp_x_vel = smooth(diff(analyzed(ind).x(boutAlign(l)-30:boutAlign(l)+21)),3);
                            if analyzed(ind).x(end) > analyzed(ind).x(1) 
                                pointed = 1; %1 for pointed right
                            else pointed = -1; end % -1 for pointed left
                            %Moving up or down?
                            U_D = ones(length(tmp_x_vel),1); %default moving up
                            U_D(tmp_y_vel<0) = -1; %frames moving down
                            %Moving left or right?
                            R_L = ones(length(tmp_x_vel),1); %default moving left
                            R_L(tmp_x_vel>0) = -1; %frames moving right
                            %calculate heading
                            PropBoutAlignedHeading(end+1,1:51) = 90.*(pointed + R_L).*pointed.*U_D + pointed.*(atand(tmp_y_vel ./ tmp_x_vel));                       

                            %if IEI is long enough, calculate vertical displacement
                            if SpdWindEnd(l)+ceil(0.1*samplerate) < SpdWindStart(l+1)-1
                                PropBoutIEIyDisplacement(end+1) = analyzed(ind).y(SpdWindStart(l+1)-1) - analyzed(ind).y(SpdWindEnd(l)+ceil(0.1*samplerate));
                                PropBoutIEIyDisplacementTimes(end+1) = PropBoutAlignedTime(end);
                                PropBoutIEIyDisplacementMatchedIEIs(end+1) = (SpdWindStart(l+1) - SpdWindStart(l))/samplerate;
                            end
                        end

                        clear swimBoutPeakIndex boutWindowStart boutWindowEnd;
                    end

                    %fill some concatenating variables
                    PropBoutTime(end+1:end+l) = boutPeakHour-floor(boutPeakHour/24)*24;
                    PropBoutMaxSpd(end+1:end+l) = boutSwimSpdMax;
                    PropBoutMaxAngVel(end+1:end+l) = boutMaxAbsAngVel;
                    PropBoutPeakAngVel(end+1:end+l) = boutPeakAngVel;

                    %calculate corresponding pitch and angular velocity for inter-event intervals (IEIs)
                    %include window from SpdWindEnd to next SpdWindStart padded
                    %with 100msec (postBoutBuffer)
                    postPeakBuffer = ceil(0.3*samplerate); %in frames   
                    prePeakBuffer = ceil(0.1*samplerate);
                    for IEI=1:length(SpdWindEnd)-1                
                        if length(smoothedAngVel) >= (SpdWindEnd(IEI)+postPeakBuffer) && length(smoothedAngVel) >= SpdWindStart(IEI+1)-prePeakBuffer
                            %save in output var the intervals between propulsive bouts in seconds, and time of IEI
                            PropBoutIEI(end+1) = diff(SpdWindStart(IEI:IEI+1))./samplerate; 
                            PropBoutIEItime(end+1) = PropBoutTime(end-length(SpdWindEnd)+1+IEI);
                            PropBoutIEIpitch(end+1) = mean(analyzed(ind).absOrientation(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                            PropBoutIEIangVel(end+1) = mean(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                            PropBoutIEIangAcc(end+1) = mean(diff(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer)))*samplerate;
                            PropBoutIEIalignedAngVel{end+1} = smoothedAngVel(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                            PropBoutIEIalignedPitch{end+1} = analyzed(ind).absOrientation(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                        end
                    end

                    %clear epoch-specific variables that have been concatenated
                    clear boutPeakHour boutSwimSpdMax boutMaxAbsAngVel boutWindowStart boutWindowEnd boutAlignedAccel;
                    clear boutMaxAbsAngVel boutPeakAngVel boutAlign boutPeakAccel boutAlignedAngVel boutAlignedSpeed;
                end

                clear SpdWindStart SpdWindEnd swimSpeed trueAngAcc baselineAngVels;
                clear epochDur;
            end

            % collate all trajectories
            smoothLevel = 3; %for smoothing motion to calculate instantaneous trajectory             
            for ii=1:length(analyzed) %for every epoch
                epochDur = length(analyzed(ii).y); %duration of present epoch.
                %adjust to 0 deg equals forward horizontally.
                smoothYvelFULL = smooth(analyzed(ii).yvel,smoothLevel);
                smoothYvel = smoothYvelFULL(1+edge_size:end-edge_size);
                smoothXvelFULL = smooth(analyzed(ii).xvel,smoothLevel);
                smoothXvel = smoothXvelFULL(1+edge_size:end-edge_size);

                for j=1:epochDur-1-2*edge_size
                    %if fish is moving left, trajectory up-left is positive; if
                    %moving right, trajectory up-right is positive.
                    if smoothXvel(j)>0 %if fish is moving right
                        if analyzed(ii).x(end) > analyzed(ii).x(1) %and pointed right
                            Traj(j) = atand(smoothYvel(j)/smoothXvel(j));% positive angles are up, negative are down
                        else %moving right and pointed left
                            if smoothYvel(j) > 0 %moving up and right and pointed left
                                Traj(j) = 180 - atand(smoothYvel(j)/smoothXvel(j));% angle is shy of 180
                            else %moving down and right and pointed left
                                Traj(j) = -180 - atand(smoothYvel(j)/smoothXvel(j));%angle is shy of -180
                            end
                        end
                    else %fish is moving left
                        if analyzed(ii).x(end) < analyzed(ii).x(1) %and pointed left
                            Traj(j) = -atand(smoothYvel(j)/smoothXvel(j));% negative angles are up, positive are down
                        else %moving left and pointed right
                            if smoothYvel(j) > 0 %moving up and left and pointed right
                                Traj(j) = 180 + atand(smoothYvel(j)/smoothXvel(j));% angle is shy of 180
                            else %moving down and left and pointed right
                                Traj(j) = -180 + atand(smoothYvel(j)/smoothXvel(j));% angle is shy of -180
                            end
                        end
                    end
                end

                AllTrajectory(end+1:end+length(Traj)) = Traj;
                TrajectoryMatchedAngles(end+1:end+epochDur-1-2*edge_size) = analyzed(ii).absOrientation(1+edge_size:end-edge_size-1);
                TrajectoryMatchedSpeeds(end+1:end+epochDur-1-2*edge_size) = ((analyzed(ii).xvel(1+edge_size:end-edge_size)).^2 + (analyzed(ii).yvel(1+edge_size:end-edge_size)).^2).^.5;
                TrajectoryMatchedAngVels(end+1:end+epochDur-1-2*edge_size) = (analyzed(ii).angularVelocity(1+edge_size:end-edge_size));
                TrajectoryMatchedTimes(end+1:end+epochDur-1-2*edge_size) = analyzed(ii).absHours(1+edge_size:end-edge_size-1) + analyzed(ii).absMins(1+edge_size:end-edge_size-1)/60 + analyzed(ii).absSecs(1+edge_size:end-edge_size-1)/3600;
                TrajectoryMatchedTimes = TrajectoryMatchedTimes - floor(TrajectoryMatchedTimes/24)*24;
                clear Traj;
            end
            
            % clear epoch after analysis
            clear raw analyzed;
        end
        close(hh);
        cd ..
    end

    %convert PropBoutIEItime to 0-24hrs
    PropBoutIEItime = PropBoutIEItime-(floor(PropBoutIEItime/24))*24;

    % save output variables
    clear ans BoutPairTicker clutchFolder d edge_size epochDur filenames filenum hh IEI
    clear ii ind isub k l nameFolds postPeakBuffer prePeakBuffer samplerate 
    clear smoothedAngVel speedThreshold windowFrame z

    currentFolder = pwd;
%     save(['Group_' currentFolder(end-4:end)])
    save('Group_data')
    cd ..
end


%% Preprocess raw data by clutch
% Some parameters
edge_size = 5; %number of samples to remove from the beginning and end of each vector to account for edge effects (improper detection of fish body as it leaves field of view)
samplerate = 40; %in Hz
speedThreshold = 5; %mm/s, speed threshold for identifying bouts

% Loop through folders corresponding to each clutch and analyze contents
for groupFolderMaster=3:length(nameFolds_master)    
    cd(nameFolds_master{groupFolderMaster})
    
    d = dir;
    isub = [d(:).isdir]; %# returns logical vector
    nameFolds = {d(isub).name}';
    
    for clutchFolder=1:(length(nameFolds)-2)
        cd(nameFolds{clutchFolder+2})  

        %Run in folder containing *.dlm files generated by VerticalFish LabView file
        filenames = dir('*.dlm');
        hh = waitbar(0,['Analyzing Clutch ' num2str(clutchFolder)]);

        % Initialize concatenating variables, described where filled
        %General variables
        BodyAngles = []; GrabbedTimes = [];
        TrajectoryMatchedAngles = []; TrajectoryMatchedTimes = []; TrajectoryMatchedSpeeds = []; 
        TrajectoryMatchedAngVels = []; AllTrajectory=[];

        %Output variables for propulsive bouts
        PropBoutTime = []; PropBoutDuration = []; PropBoutDisplacement = [];
        PropBoutMaxSpd = []; PropBoutMaxAngVel = []; PropBoutPeakAngVel = [];
        PropBoutIEI = []; PropBoutIEItime = []; PropBoutIEIpitch = []; 
        PropBoutIEIangVel = []; PropBoutIEIangAcc = [];
        PropBoutIEIalignedPitch{1} = []; PropBoutIEIalignedAngVel{1} = [];
        PropBoutIEIyDisplacement = []; PropBoutIEIyDisplacementTimes = [];
        PropBoutIEIyDisplacementMatchedIEIs = [];

        %Output variables aligned to peak translation of propulsive bout
        PropBoutAlignedTime = []; PropBoutAlignedPitch = []; PropBoutAlignedAngVel = [];
        PropBoutAlignedSpeed = []; PropBoutInitPitch = []; PropBoutNetPitchChg = []; 
        PropBoutAlignedHeading = [];

        % Loop through each file
        for filenum=1:length(filenames)
            %Load raw data and pre-process to parse out epochs
            raw = dlmread(filenames(filenum).name);
            analyzed = Preprocess_LabView_output_ES19(raw,filenum);
            % Loop through each epoch of the pre-processed file
            for ind=1:length(analyzed) 
                epochDur = length(analyzed(ind).y); %duration of present epoch
                %Calculate swim speed for each frame using Pythagorean theorem with
                %horizontal and vertical translation velocities
                for z = 1:epochDur-1
                    swimSpeed(z) = sqrt((analyzed(ind).xvel(z))^2 + (analyzed(ind).yvel(z))^2);
                end
                % Smoothing angular velocity to de-noise               
                smoothedAngVel = smooth(analyzed(ind).angularVelocity, 3);

                % Concatenate values for each frame while cycling through each epoch 
                GrabbedTimes(end+1:end+length(analyzed(ind).absHours)) = analyzed(ind).absHours + analyzed(ind).absMins/60 + analyzed(ind).absSecs/3600; %time in hours
                BodyAngles(end+1:end+length(analyzed(ind).absOrientation)) = analyzed(ind).absOrientation;
                waitbar(((filenum-1)+(ind/length(analyzed)))/length(filenames),hh);

                % Identify swim bouts and store peak translation speed and rotation speed             
                clear SpdWindStart SpdWindEnd;
                %find local maxima for speed above SpeedThreshold
                if max(swimSpeed(1:end-1)) >= speedThreshold %if fish swims faster than threshold
                    %identify start and end of window when fish crosses threshold
                    k = 1;
                    SpdWindStart(1) = 1;
                    while SpdWindStart(k) < epochDur-1 %for entire epoch
                        %find bout window start
                        try SpdWindEnd(k); %if there is an end to epoch 'k', advance that end if still above threshold or start a new epoch
                            %added the subsequent 'try' statement in case the end point is past the swimSpeed length. there is surely a better way to do this, but for now this fixes the problem. 
                            try swimSpeed(SpdWindEnd(k));
                                if swimSpeed(SpdWindEnd(k)) >= speedThreshold %if we are still above threshold
                                    SpdWindEnd(k) = SpdWindEnd(k)+1;                %advance end of window
                                else
                                    k = k+1;                                      %start a new epoch
                                    SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                                end
                             catch
                                k = k+1;                                      %start a new epoch
                                SpdWindStart(k) = SpdWindEnd(k-1)+1;          %with a start immediately following previous end, to be advanced until next bout
                             end
                        catch %if there is no end to epoch 'k', advance start or make an end
                            if swimSpeed(SpdWindStart(k)) < speedThreshold %if start of window 'k' is below threshold
                                SpdWindStart(k) = SpdWindStart(k) + 1; %advance start of window 'k'
                            else
                                SpdWindEnd(k) = SpdWindStart(k)+1; %if start is above threshold, make an end for this threshold
                            end
                        end
                    end

                    %if the last value of SpdWindEnd exceeds the length of swimSpeed, set it equal to the length of swimSpeed
                    try swimSpeed(SpdWindEnd(end));
                    catch SpdWindEnd(end) = length(swimSpeed);
                    end

                    % Check if SpdWindStarts are realistically spaced to constitute separate bouts (> 100ms). 
                    % If not, combine the bouts by using the first SpdWindStart and second SpdWindEnd
                    % Note: manually capping detected frequency at 10Hz
                    windowFrame = 1;                
                    while windowFrame<length(SpdWindEnd)
                        if SpdWindStart(windowFrame+1) - SpdWindEnd(windowFrame) < (ceil(samplerate/10)) %if difference in samples is less than 100 ms
                            SpdWindEnd(windowFrame) = SpdWindEnd(windowFrame+1);
                            %delete at windowFrame+1 index
                            SpdWindStart(windowFrame+1) = [];
                            SpdWindEnd(windowFrame+1) = [];
                            windowFrame = windowFrame - 1;
                        end
                        windowFrame = windowFrame+1;
                    end

                    % Isolate and analyze bouts
                    BoutPairTicker = 0;
                    for l=1:length(SpdWindEnd)
                        %find index for peak speed of bout
                        swimBoutPeakIndex = SpdWindStart(l)-1+find(swimSpeed(SpdWindStart(l):SpdWindEnd(l))==max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)))); 
                        %define window for surrounding bout
                        boutWindowStart = swimBoutPeakIndex-ceil(0.3*samplerate);
                        boutWindowEnd = swimBoutPeakIndex+ceil(0.3*samplerate);
                        %keep within epoch
                        if boutWindowStart < 1; boutWindowStart = 1; end                
                        if boutWindowEnd > length(analyzed(ind).angularVelocity(1+edge_size:end-edge_size))-1+edge_size; boutWindowEnd = length(analyzed(ind).angularVelocity(1+edge_size:end-edge_size))-1+edge_size; end
                        %max translation speed
                        boutSwimSpdMax(l) = max(swimSpeed(SpdWindStart(l):SpdWindEnd(l)));    
                        %calculate time of bout from hours, minutes, and seconds
                        boutPeakHour(l) = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                        %maximum angular velocity during bout
                        boutMaxAbsAngVel(l) = max(abs(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l))));
                        %duration and displacement of bout
                        PropBoutDuration(end+1) = (SpdWindEnd(l)-SpdWindStart(l))/samplerate; %duration above speed threshold (5 mm/sec) in seconds
                        PropBoutDisplacement(end+1) = sqrt((analyzed(ind).x(boutWindowEnd)-analyzed(ind).x(boutWindowStart))^2+(analyzed(ind).y(boutWindowEnd)-analyzed(ind).y(boutWindowStart))^2);

                        %calculate peak angular velocity of this bout (largest magnitude, nose-up or -down)
                        if abs(min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))) > max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)))
                            boutPeakAngVel(l) = min(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                        else boutPeakAngVel(l) = max(analyzed(ind).angularVelocity(SpdWindStart(l):SpdWindEnd(l)));
                        end

                        % Record bout data aligned to propulsive peak
                        %if window is far enough from edge to allow alignment
                        %AND values during pre and post peak window are sufficiently low
                        if swimBoutPeakIndex > 30 && swimBoutPeakIndex < length(analyzed(ind).angularVelocity)-20 && min(swimSpeed(swimBoutPeakIndex-10:swimBoutPeakIndex)) < 3 && min(swimSpeed(swimBoutPeakIndex:boutWindowEnd)) < 3
                            boutAlign(l) = swimBoutPeakIndex;
                            PropBoutAlignedAngVel(end+1,1:51) = smoothedAngVel(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutAlignedSpeed(end+1,1:51) = swimSpeed(boutAlign(l)-30:boutAlign(l)+20);
                            PropBoutAlignedPitch(end+1,1:51) = analyzed(ind).absOrientation(boutAlign(l)-30:boutAlign(l)+20);                                               
                            PropBoutInitPitch(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)-10:boutAlign(l)-5));
                            PropBoutNetPitchChg(end+1) = mean(analyzed(ind).absOrientation(boutAlign(l)+5:boutAlign(l)+10)) - PropBoutInitPitch(end);
                            AlignedTime = analyzed(ind).absHours(swimBoutPeakIndex) + analyzed(ind).absMins(swimBoutPeakIndex)/60 + analyzed(ind).absSecs(swimBoutPeakIndex)/3600; %time in hours
                            PropBoutAlignedTime(end+1) = AlignedTime - floor(AlignedTime/24)*24; %time in hours for light/dark comparison

                            %Trajectory
                            clear pointed U_D R_L
                            tmp_y_vel = smooth(diff(analyzed(ind).y(boutAlign(l)-30:boutAlign(l)+21)),3);
                            tmp_x_vel = smooth(diff(analyzed(ind).x(boutAlign(l)-30:boutAlign(l)+21)),3);
                            if analyzed(ind).x(end) > analyzed(ind).x(1) 
                                pointed = 1; %1 for pointed right
                            else pointed = -1; end % -1 for pointed left
                            %Moving up or down?
                            U_D = ones(length(tmp_x_vel),1); %default moving up
                            U_D(tmp_y_vel<0) = -1; %frames moving down
                            %Moving left or right?
                            R_L = ones(length(tmp_x_vel),1); %default moving left
                            R_L(tmp_x_vel>0) = -1; %frames moving right
                            %calculate heading
                            PropBoutAlignedHeading(end+1,1:51) = 90.*(pointed + R_L).*pointed.*U_D + pointed.*(atand(tmp_y_vel ./ tmp_x_vel));                       

                            %if IEI is long enough, calculate vertical displacement
                            if SpdWindEnd(l)+ceil(0.1*samplerate) < SpdWindStart(l+1)-1
                                PropBoutIEIyDisplacement(end+1) = analyzed(ind).y(SpdWindStart(l+1)-1) - analyzed(ind).y(SpdWindEnd(l)+ceil(0.1*samplerate));
                                PropBoutIEIyDisplacementTimes(end+1) = PropBoutAlignedTime(end);
                                PropBoutIEIyDisplacementMatchedIEIs(end+1) = (SpdWindStart(l+1) - SpdWindStart(l))/samplerate;
                            end
                        end

                        clear swimBoutPeakIndex boutWindowStart boutWindowEnd;
                    end

                    %fill some concatenating variables
                    PropBoutTime(end+1:end+l) = boutPeakHour-floor(boutPeakHour/24)*24;
                    PropBoutMaxSpd(end+1:end+l) = boutSwimSpdMax;
                    PropBoutMaxAngVel(end+1:end+l) = boutMaxAbsAngVel;
                    PropBoutPeakAngVel(end+1:end+l) = boutPeakAngVel;

                    %calculate corresponding pitch and angular velocity for IEIs
                    %include window from SpdWindEnd to next SpdWindStart padded
                    %with 100msec (postBoutBuffer)
                    postPeakBuffer = ceil(0.3*samplerate); %in frames   
                    prePeakBuffer = ceil(0.1*samplerate);
                    for IEI=1:length(SpdWindEnd)-1                
                        if length(smoothedAngVel) >= (SpdWindEnd(IEI)+postPeakBuffer) && length(smoothedAngVel) >= SpdWindStart(IEI+1)-prePeakBuffer
                            %save in output var the intervals between propulsive bouts in seconds, and time of IEI
                            PropBoutIEI(end+1) = diff(SpdWindStart(IEI:IEI+1))./samplerate; 
                            PropBoutIEItime(end+1) = PropBoutTime(end-length(SpdWindEnd)+1+IEI);
                            PropBoutIEIpitch(end+1) = mean(analyzed(ind).absOrientation(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                            PropBoutIEIangVel(end+1) = mean(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer));
                            PropBoutIEIangAcc(end+1) = mean(diff(smoothedAngVel(SpdWindEnd(IEI)+postPeakBuffer:SpdWindStart(IEI+1)-prePeakBuffer)))*samplerate;
                            PropBoutIEIalignedAngVel{end+1} = smoothedAngVel(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                            PropBoutIEIalignedPitch{end+1} = analyzed(ind).absOrientation(SpdWindEnd(IEI)+ceil(0.05*samplerate):SpdWindStart(IEI+1)-prePeakBuffer);
                        end
                    end

                    %clear epoch-specific variables that have been concatenated
                    clear boutPeakHour boutSwimSpdMax boutMaxAbsAngVel boutWindowStart boutWindowEnd boutAlignedAccel;
                    clear boutMaxAbsAngVel boutPeakAngVel boutAlign boutPeakAccel boutAlignedAngVel boutAlignedSpeed;
                end

                clear SpdWindStart SpdWindEnd swimSpeed trueAngAcc baselineAngVels;
                clear epochDur;
            end

            % collate all trajectories
            edge_size = 5; smoothLevel = 3; %for smoothing motion to calculate instantaneous trajectory             
            for ii=1:length(analyzed) %for every epoch
                epochDur = length(analyzed(ii).y); %duration of present epoch.
                %adjust to 0 deg equals forward horizontally.
                smoothYvelFULL = smooth(analyzed(ii).yvel,smoothLevel);
                smoothYvel = smoothYvelFULL(1+edge_size:end-edge_size);
                smoothXvelFULL = smooth(analyzed(ii).xvel,smoothLevel);
                smoothXvel = smoothXvelFULL(1+edge_size:end-edge_size);

                for j=1:epochDur-1-2*edge_size
                    %if fish is moving left, trajectory up-left is positive; if
                    %moving right, trajectory up-right is positive.
                    if smoothXvel(j)>0 %if fish is moving right
                        if analyzed(ii).x(end) > analyzed(ii).x(1) %and pointed right
                            Traj(j) = atand(smoothYvel(j)/smoothXvel(j));% positive angles are up, negative are down
                        else %moving right and pointed left
                            if smoothYvel(j) > 0 %moving up and right and pointed left
                                Traj(j) = 180 - atand(smoothYvel(j)/smoothXvel(j));% angle is shy of 180
                            else %moving down and right and pointed left
                                Traj(j) = -180 - atand(smoothYvel(j)/smoothXvel(j));%angle is shy of -180
                            end
                        end
                    else %fish is moving left
                        if analyzed(ii).x(end) < analyzed(ii).x(1) %and pointed left
                            Traj(j) = -atand(smoothYvel(j)/smoothXvel(j));% negative angles are up, positive are down
                        else %moving left and pointed right
                            if smoothYvel(j) > 0 %moving up and left and pointed right
                                Traj(j) = 180 + atand(smoothYvel(j)/smoothXvel(j));% angle is shy of 180
                            else %moving down and left and pointed right
                                Traj(j) = -180 + atand(smoothYvel(j)/smoothXvel(j));% angle is shy of -180
                            end
                        end
                    end
                end

                AllTrajectory(end+1:end+length(Traj)) = Traj;
                TrajectoryMatchedAngles(end+1:end+epochDur-1-2*edge_size) = analyzed(ii).absOrientation(1+edge_size:end-edge_size-1);
                TrajectoryMatchedSpeeds(end+1:end+epochDur-1-2*edge_size) = ((analyzed(ii).xvel(1+edge_size:end-edge_size)).^2 + (analyzed(ii).yvel(1+edge_size:end-edge_size)).^2).^.5;
                TrajectoryMatchedAngVels(end+1:end+epochDur-1-2*edge_size) = (analyzed(ii).angularVelocity(1+edge_size:end-edge_size));
                TrajectoryMatchedTimes(end+1:end+epochDur-1-2*edge_size) = analyzed(ii).absHours(1+edge_size:end-edge_size-1) + analyzed(ii).absMins(1+edge_size:end-edge_size-1)/60 + analyzed(ii).absSecs(1+edge_size:end-edge_size-1)/3600;
                TrajectoryMatchedTimes = TrajectoryMatchedTimes - floor(TrajectoryMatchedTimes/24)*24;
                clear Traj;
            end

            % clear epoch after analysis
            clear raw analyzed;
        end

        %convert PropBoutIEItime to 0-24hrs
        PropBoutIEItime = PropBoutIEItime-(floor(PropBoutIEItime/24))*24;

        close(hh);

        % save output variables
        clear ans BoutPairTicker d epochDur filenames filenum hh IEI
        clear ii ind isub k l postPeakBuffer prePeakBuffer 
        clear smoothedAngVel windowFrame z

        currentFolder = pwd;
        save(['Clutch_' num2str(clutchFolder) '_data'])

        cd ..
    end

    cd ..
end


%% Generate Figure 1 - comparison of control and finless swimming at 21dpf
nameFolds_F1 = {'Amputation_control_21dpf','Amputation_21dpf'};
figure;
for group_F1=1:length(nameFolds_F1)
    cd(nameFolds_F1{group_F1})
    
    %load data
    matname=dir('*mat');
    load(matname.name);
    
    %plot Figure 1B: Trajectory vs. posture
    heading_lim=90;
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
    subplot(2,3,group_F1); hold on;
    plot(PropBoutAlignedPitch(day,31),PropBoutAlignedHeading(day,31),'.')
    hold on; plot([-90 90],[-90 90],'r') %unity line
    axis square; axis([-35 45 -90 90]); xlabel('Posture (deg)'); ylabel('Trajectory (deg)');

    dclutch_F1 = dir;
    iclutch_F1 = [dclutch_F1(:).isdir]; %# returns logical vector
    nameClutch_F1 = {dclutch_F1(iclutch_F1).name}';
    for clutch_F1=1:6
        cd(nameClutch_F1{clutch_F1+2})

        %load data
        matname=dir('*mat');
        load(matname.name);
        %calculate mean attack angle for clutch
        heading_lim=90;
        [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
        atk_angles_F1(group_F1,clutch_F1)=mean(PropBoutAlignedHeading(day,31)-PropBoutAlignedPitch(day,31));
        
        %calculate cumulative probability distribution            
        climb_min = 20; %threshold for "steep climbs"
        edges=-90:0.1:90; %define bins for cumulative probability distribution
        centers=edges(1:end-1)+diff(edges(1:2))/2;%bin centers for plotting
        counts_F1(:,clutch_F1,group_F1)=cumsum(histc(PropBoutAlignedPitch(day(PropBoutAlignedHeading(day,31)>climb_min),31),edges)./length(day(PropBoutAlignedHeading(day,31)>climb_min)));
        
        %calculate deviation from horizontal during steep climbs
        climb_deviation_F1(group_F1,clutch_F1) = mean(abs(PropBoutAlignedPitch(day(PropBoutAlignedHeading(day,31)>climb_min),31)));
%         climb_deviation_F1(clutch_F1,group_F1) = mean(abs(PropBoutAlignedPitch(day(find(PropBoutAlignedHeading(day,31)>climb_min)),31)));

        cd ..
    end
    cd ..
end

subplot(2,3,1); title('Figure 1B: Control')
subplot(2,3,2); title('Figure 1B: Finless')
%Plot figure 1D
subplot(2,3,4); hold on; for i=1:6; plot([1 2],atk_angles_F1(:,i),'.-','markersize',4,'color',[.5 .5 .5]); end
title('Figure 1D'); axis square; axis([0.8 2.2 -20 38]); xlabel('control   finless'); ylabel('Attack angle (deg)')
%Plot figure 1E
subplot(2,3,5); hold on; plot(centers, mean(counts_F1(1:end-1,:,1),2),'k','linewidth',2);
plot(centers, mean(counts_F1(1:end-1,:,1),2)+std(counts_F1(1:end-1,:,1),1,2),'k');
plot(centers, mean(counts_F1(1:end-1,:,1),2)-std(counts_F1(1:end-1,:,1),1,2),'k');
plot(centers, mean(counts_F1(1:end-1,:,2),2),'r','linewidth',2);
plot(centers, mean(counts_F1(1:end-1,:,2),2)+std(counts_F1(1:end-1,:,2),1,2),'r');
plot(centers, mean(counts_F1(1:end-1,:,2),2)-std(counts_F1(1:end-1,:,2),1,2),'r');
title('Figure 1E'); axis square; axis([-10 50 0 1]); ylabel('Cumulative probability'); xlabel('Posture (deg)');
%Plot figure 1F
subplot(2,3,6); hold on; for i=1:6; plot([1 2],climb_deviation_F1(:,i),'.-','markersize',4,'color',[.5 .5 .5]); end
axis square; axis([0.8 2.2 11 29]); title('Figure 1F'); 
xlabel('control    finless'); ylabel('Deviation from horz posture (deg)')

%% Generate Figure 1 Supplement 1 - relationship between speed and trajectory
figure('outerposition',[100 100 600 300]); %initialize figure
nameFolds_F1S1 = '07dpf';
cd(nameFolds_F1S1)

dclutch_F1S1 = dir;
iclutch_F1S1 = [dclutch_F1S1(:).isdir]; %# returns logical vector
nameClutch_F1S1 = {dclutch_F1S1(iclutch_F1S1).name}';
for clutch_F1S1=1:4
    cd(nameClutch_F1S1{clutch_F1S1+2})
    %load data
    matname=dir('*mat');
    load(matname.name);
    %bin instantaneous trajectory vs. speed data for clutch
    [day,~]=lightdarksplit(TrajectoryMatchedTimes);
    [xout,yout]=makeEvenHistogram(TrajectoryMatchedSpeeds(day),AllTrajectory(day),500);
    subplot(1,4,1); semilogx(xout,yout,'color',[.8 .8 .8]); hold on;
    cd ..
end

matname=dir('*mat');
load(matname.name);
%bin for group
[day,~]=lightdarksplit(TrajectoryMatchedTimes);
[xout,yout]=makeEvenHistogram(TrajectoryMatchedSpeeds(day),AllTrajectory(day),2500);
subplot(1,4,1); hold on; semilogx(xout,yout,'k');
axis square; axis([.01 30 -90 30])
title('Figure 1 Supp1B'); xlabel('Speed (mm/sec)'); ylabel('Trajectory (deg)');

%Panel C: compute polar histogram when moving faster than 5 mm/sec
edges = -180:4:180;
centers = edges(1:end-1) + diff(edges(1:2))/2;
counts = histc(AllTrajectory(find(TrajectoryMatchedSpeeds>5)), edges)./ length(find(TrajectoryMatchedSpeeds>5));
ring = zeros(1,length(counts)-1); ring(:)=0.1;
subplot(1,4,2); 
polar(centers*pi/180, ring); hold on;
polar(centers*pi/180, counts(1:end-1));
title('Fig 1 Supp 1C-fastest')

%Panel C: compute polar histogram when moving slower than 1 mm/sec
counts = histc(AllTrajectory(find(TrajectoryMatchedSpeeds<1)), edges)./ length(find(TrajectoryMatchedSpeeds<1));
subplot(1,4,3); 
polar(centers*pi/180, ring); hold on;
polar(centers*pi/180, counts(1:end-1));
title('Fig 1 Supp 1C-slowest')
cd ..

%Panel D:
nameFolds_F1S1 = '21dpf';
cd(nameFolds_F1S1)
matname=dir('*mat');
load(matname.name);
%find daytime frames
[day,~]=lightdarksplit(PropBoutIEIyDisplacementTimes);
%plot inter-bout displacement vs. duration
subplot(1,4,4); semilogx(PropBoutIEIyDisplacementMatchedIEIs(day),PropBoutIEIyDisplacement(day),'.','color',[.8 .8 .8])
%plot binned data
[xout,yout]=makeEvenHistogram(PropBoutIEIyDisplacementMatchedIEIs(day),PropBoutIEIyDisplacement(day),15);
hold on; semilogx(xout,yout,'k')
axis([0.1 10 -4 4]); axis square; ylabel('Vertical displacement (mm)'); xlabel('Inter-bout duration (sec)');
title('Fig1 Supp1 D');
cd ..

%% Generate Figure 1 Supplement 2 - temporally aligned postures during finless and control bouts
figure('outerposition',[200 200 600 300]); %initialize figure
nameFolds_F1S2 = {'Amputation_control_21dpf','Amputation_21dpf'};
colors_F1S2={'k','r'};
for group_F1S2=1:2
    cd(nameFolds_F1S2{group_F1S2})

    %load data
    matname=dir('*mat');
    load(matname.name);

    %plot temporally-aligned postures
    [day,~]=lightdarksplit(PropBoutAlignedTime);
    subplot(1,3,group_F1S2); plot(-0.1:0.025:0.15,PropBoutAlignedPitch(day,27:37)-PropBoutAlignedPitch(day,28),'color',[.8 .8 .8])
    hold on; plot(-0.1:0.025:0.15,mean(PropBoutAlignedPitch(day,27:37)-PropBoutAlignedPitch(day,28)),'k','linewidth',2)
    
    %plot temporally-aligned angular speed
    subplot(1,3,3); pitem(group_F1S2)=plot(-0.25:0.025:0.25, mean(abs(PropBoutAlignedAngVel(day,21:41))),'color',colors_F1S2{group_F1S2},'linewidth',2);
    hold on; plot(-0.25:0.025:0.25, mean(abs(PropBoutAlignedAngVel(day,21:41)))+std(abs(PropBoutAlignedAngVel(day,21:41))),'color',colors_F1S2{group_F1S2})
    plot(-0.25:0.025:0.25, mean(abs(PropBoutAlignedAngVel(day,21:41)))-std(abs(PropBoutAlignedAngVel(day,21:41))),'color',colors_F1S2{group_F1S2})
    
    cd ..
end

subplot(1,3,1); xlabel('Time from peak (sec)'); ylabel('Posture (deg)'); title('Fig1 Supp2A - Control')
subplot(1,3,2); xlabel('Time from peak (sec)'); ylabel('Posture (deg)'); title('Finless')
subplot(1,3,3); axis([-0.25 0.25 0 80]); xlabel('Time to peak (sec)'); ylabel('Angular speed (deg/sec)');
legend([pitem(1) pitem(2)],'Control','Finless');

%% Generate Figure 1 Supplement 3 - swim bout properties as a function of age and fin amputation
nameFolds_F1S3 = {'Amputation_control_07dpf','Amputation_07dpf','Amputation_control_21dpf','Amputation_21dpf'};

for group_F1S3=1:4
    cd(nameFolds_F1S3{group_F1S3})
    
    %iterate through clutch folders
    dclutch_F1S3 = dir;
    iclutch_F1S3 = [dclutch_F1S3(:).isdir]; %# returns logical vector
    nameClutch_F1S3 = {dclutch_F1S3(iclutch_F1S3).name}';
    for clutch_F1S3=1:6
        cd(nameClutch_F1S3{clutch_F1S3+2})

        %load data
        matname=dir('*mat');
        load(matname.name);

        %isolate daytime swim bouts with accompanying posture timeseries
        [day,~]=lightdarksplit(PropBoutAlignedTime);        
        %mean posture change
        meanRot(group_F1S3,clutch_F1S3) = mean(abs(PropBoutAlignedPitch(day,30)-PropBoutAlignedPitch(day,28)));
        
        %isolate daytime inter-bout intervals
        [day,~]=lightdarksplit(PropBoutIEItime);
        %calculate bout rate from inter-bout interval
        medianIEI(group_F1S3,clutch_F1S3) = median(PropBoutIEI(day));
        meanRate(group_F1S3,clutch_F1S3) = mean(1./PropBoutIEI(day));
        
        %isolate daytime swim bouts and compute mean displacement and speed
        [day,~]=lightdarksplit(PropBoutTime);
        meanDisp(group_F1S3,clutch_F1S3) = mean(PropBoutDisplacement(day));
        meanSpd(group_F1S3,clutch_F1S3) = mean(PropBoutMaxSpd(day));
        
        cd .. 
    end
    cd ..
end

hFig = figure(1);
set(hFig, 'Position', [1 1 1200 300])
for i=1:6
    subplot(1,4,4); hold on
    plot([1 2], [meanRot(1,i) meanRot(2,i)],'k')
    plot([3 4], [meanRot(3,i) meanRot(4,i)],'k')
    
    subplot(1,4,3); hold on
    plot([1 2], [meanRate(1,i) meanRate(2,i)],'k')
    plot([3 4], [meanRate(3,i) meanRate(4,i)],'k')
    
    subplot(1,4,2); hold on
    plot([1 2], [meanDisp(1,i) meanDisp(2,i)],'k')
    plot([3 4], [meanDisp(3,i) meanDisp(4,i)],'k')

    subplot(1,4,1); hold on
    plot([1 2], [meanSpd(1,i) meanSpd(2,i)],'k')
    plot([3 4], [meanSpd(3,i) meanSpd(4,i)],'k')
end

subplot(1,4,1); ylabel('Maximal bout speed (mm/sec)'); xlabel('7con    7cut       21con     21cut')
plot([1 2], [mean(meanSpd(1,:)) mean(meanSpd(2,:))],'r','linewidth',2)
plot([3 4], [mean(meanSpd(3,:)) mean(meanSpd(4,:))],'r','linewidth',2)
axis([0.5 4.5 0 15]); title('Figure 1 Supp. 3')

subplot(1,4,2); ylabel('Bout displacement (mm)'); xlabel('7con    7cut       21con     21cut')
plot([1 2], [mean(meanDisp(1,:)) mean(meanDisp(2,:))],'r','linewidth',2)
plot([3 4], [mean(meanDisp(3,:)) mean(meanDisp(4,:))],'r','linewidth',2)
axis([0.5 4.5 0 2])

subplot(1,4,3); ylabel('Swim rate (Hz)'); xlabel('7con    7cut       21con     21cut')
plot([1 2], [mean(meanRate(1,:)) mean(meanRate(2,:))],'r','linewidth',2)
plot([3 4], [mean(meanRate(3,:)) mean(meanRate(4,:))],'r','linewidth',2)
axis([0.5 4.5 0 2.5])

subplot(1,4,4); ylabel('Body rotation (deg)'); xlabel('7con    7cut       21con     21cut')
plot([1 2], [mean(meanRot(1,:)) mean(meanRot(2,:))],'r','linewidth',2)
plot([3 4], [mean(meanRot(3,:)) mean(meanRot(4,:))],'r','linewidth',2)
axis([0.5 4.5 0 2])

for i=1:4; subplot(1,4,i); axis square; end


%% Generate Figure 2 - development of fin-tail coordination
d = dir;
isub = [d(:).isdir]; %# returns logical vector
nameFolds_F2 = {'04dpf','07dpf','14dpf','21dpf'};
colors_F2 = {'m','r','g','b'};

bootstrap_on = 1; %switch: 1 to calculate bootstrapped CIs, 0 to not
bootstrap_iter = 1000; %iterations for bootstrapping
axis_size_F2 = [-2 10 -8 25];

figure('outerposition',[100 100 900 700]); %initialize figure

%new below
for age_F2=1:4
    
    cd(nameFolds_F2{age_F2})
    
    %load data
    matname=dir('*mat');
    load(matname.name);
   
    %exclude backwards bouts
    heading_lim = 90; 
    %identify bouts during daylight
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
    %bin attack angle vs. posture change data
    [xout,yout,~,ysd] = makeEvenHistogram(PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28), PropBoutAlignedHeading(day,31)-PropBoutAlignedPitch(day,31),11);
    subplot(3,5,5+age_F2);
    plot(xout,yout); hold on;      
    axis square; axis(axis_size_F2)   
    
    atk_angles = PropBoutAlignedHeading(day,31) - PropBoutAlignedPitch(day,31);
    posture_chg = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);
    
    %calculate attack angle histogram
    edges = -90:2:90; centers=edges(1:end-1)+diff(edges(1:2))/2;
    counts = histc(atk_angles,edges)/length(atk_angles);
    subplot(3,5,10); hold on; plot(counts(1:end-1),centers,'color',colors_F2{age_F2});
    axis([0 0.5 axis_size_F2(3:4)]); axis square; xlabel('Probability')
    
    %Generate Figure 2B
    %exclude backwards bouts
    heading_lim = 90; 
    %identify bouts during daylight
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
    %plot bout speed-aligned linear acceleration    
    subplot(3,5,1); hold on;
    plot(linspace(-.75, .475,50)+0.0125, 40*mean(diff(PropBoutAlignedSpeed(day,:)')'),'color',colors_F2{age_F2})
    axis([-0.2 0.12 -300 500]); axis square   
    hold on; fill([-0.075 -0.025 -0.025 -0.075],[450 450 470 470],'b')
    xlabel('Time from peak speed (sec)'); ylabel('Linear accel (mm/sec^2)')
    title('Fig. 2B')
    %plot bout speed-aligned angular acceleration    
    subplot(3,5,2); hold on;
    plot(linspace(-.75, .475,50)+0.0125, 40*mean(diff(abs(PropBoutAlignedAngVel(day,:)'))'),'color',colors_F2{age_F2})
    axis([-0.2 0.12 -600 1000]); axis square    
    hold on; fill([-0.075 -0.025 -0.025 -0.075],[900 900 950 950],'b')
    xlabel('Time from peak speed (sec)'); ylabel('Angular accel (deg/sec^2)')
    subplot(3,5,3); hold on; plot([0 0],[0 0],'color',colors_F2{age_F2});
    
    %Fit 4 degree-of-freedom sigmoid
    sigfunc = @(A,x)(A(3)+ (A(4))./(1 + exp(-A(1)*(x- (A(1)*A(2)+log(-(A(3)-(7)*A(4))/(A(3)+A(4))))/A(1) ))));
    A0 = [1 -1 -0.2 20]; % Initial values for solver
    
    %calculate bootstrapped SD
    if bootstrap_on == 1
        clear sig_med sig_hi sig_low
        sig_x = -20:0.01:40; %sigmoid abscissa
        for bs_iter = 1:bootstrap_iter
            %fit sigmoid for random subsample
            inds = randi(length(posture_chg),length(posture_chg),1);
            A_fit = lsqcurvefit(sigfunc, A0, posture_chg(inds), atk_angles(inds), [-inf -10 -inf], [inf 10 inf]);            
            bs_sigmoid(bs_iter, :) = sigfunc(A_fit, sig_x);        
        end
        %calculate standard deviation of best-fit sigmoids
        sig_mean = mean(bs_sigmoid);
        sig_sd = std(bs_sigmoid);
        sig_hi = sig_mean+sig_sd;
        sig_low = sig_mean-sig_sd;
    end

    %solve best-fit sigmoid for full dataset
    [A_fit, resnorm, R, ~, ~, ~, J] = lsqcurvefit(sigfunc, A0, posture_chg, atk_angles);
    A_fit_CI = nlparci(A_fit, R, 'jacobian', J, 'alpha', 0.05);
    %goodness-of-fit
    rsqq(age_F2) = 1-resnorm/sum((atk_angles-mean(atk_angles)).^2);   

    %calculate best-fit sigmoid properties and confidence intervals
    %steepness
    steepness(age_F2) = A_fit(1);
    steepness_hi(age_F2) = A_fit_CI(1,2);
    steepness_low(age_F2) = A_fit_CI(1,1);        
    %maximal slope
    slope(age_F2) = A_fit(4)*A_fit(1)/4;
    slopeHi(age_F2) = A_fit(4)*A_fit_CI(1,1)/4;
    slopeLow(age_F2) = A_fit(4)*A_fit_CI(1,2)/4;        
    %amplitude
    height(age_F2) = A_fit(4);
    height_hi(age_F2) = A_fit_CI(4,2);
    height_low(age_F2) = A_fit_CI(4,1);
    %location
    posY(age_F2) = A_fit(3);
    posY_hi(age_F2) = A_fit_CI(3,2);
    posY_low(age_F2) = A_fit_CI(3,1);        
    posX(age_F2) = A_fit(2);        
    posX_hi(age_F2) = A_fit_CI(2,2);
    posX_low(age_F2) = A_fit_CI(2,1);            

    %plot best-fit sigmoid with bootstrapped SD
    subplot(3,5,5+age_F2);
    hold on; plot(-20:0.2:20, sigfunc(A_fit, -20:0.2:20),'color',colors_F2{age_F2});
    if bootstrap_on==1
        plot(sig_x, sig_low, 'color',colors_F2{age_F2});
        plot(sig_x, sig_hi, 'color',colors_F2{age_F2});
    end
    axis square; axis(axis_size_F2); title(num2str(nameFolds_F2{age_F2}))
    if age_F2==1; ylabel('Attack angle (deg)'); end
    xlabel('Posture change (deg)')
    
    %fit 1 degree-of-freedom sigmoid
    atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
    locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))
    posX8 = -1.11; %Mean across ages of 4dof sigmoid fits for (A(2)) when one_nth=8;
    one_nth = 8; %constrain sigmoid to point at 1/8th height
    sigfunc = @(A,x)(locY+ (atk_max)./(1 + exp(-A*(x- (A*posX8+log(-(locY-(one_nth-1)*atk_max)/(locY+atk_max)))/A ))));
    A0 = 1; % Initial value for solver               
    
    %solve best-fit sigmoid
    [A_fit, resnorm, R, ~, ~, ~, J] = lsqcurvefit(sigfunc,A0,posture_chg,atk_angles);
    A_fit_CI = nlparci(A_fit,R,'jacobian',J,'alpha',0.05);
    %goodness-of-fit
    rsqq(age_F2) = 1-resnorm/sum((atk_angles-mean(atk_angles)).^2);   

    %sigmoid maximal slope
    slope_1dof(age_F2) = atk_max*A_fit(1)/4;
    slopeHi_1dof(age_F2) = atk_max*A_fit_CI(1,1)/4;
    slopeLow_1dof(age_F2) = atk_max*A_fit_CI(1,2)/4;
%     fin_bias_1dof(age_F2) = slope_1dof(age_F2)/(1+slope_1dof(age_F2));
%     fin_bias_1dof_hi(age_F2) = slopeHi_1dof(age_F2)/(1+slopeHi_1dof(age_F2));
%     fin_bias_1dof_low(age_F2) = slopeLow_1dof(age_F2)/(1+slopeLow_1dof(age_F2));
    
    mean_atk_angle(age_F2) = mean(atk_angles);    
    
    cd ..
end

emp_fin_bias = slope_1dof./(1+slope_1dof);
emp_fin_bias_Hi = slopeHi_1dof./(1+slopeHi_1dof);
emp_fin_bias_Low = slopeLow_1dof./(1+slopeLow_1dof);

subplot(3,5,3); axis square; legend('4dpf','07','14','21')

subplot(3,5,11); title('Fig. 2D: slope')
hold on; errorbar([4 7 14 21],slope_1dof, slope_1dof-slopeLow_1dof, slopeHi_1dof-slope_1dof);
ylabel('Fin-body ratio'); xlabel('Age (dpf)'); axis square; axis([0 25 0 15]);

%calculate best-fit sigmoid by clutch
cd('Development_48hr')

d_F2clutch = dir;
isub_F2clutch = [d_F2clutch(:).isdir]; 
nameFolds_F2clutch = {d_F2clutch(isub_F2clutch).name}';

% Iterate through folders corresponding to each clutch
for clutch_F2=1:(length(nameFolds_F2clutch)-2)
    cd(nameFolds_F2clutch{clutch_F2+2})  

    %load data
    matname=dir('*mat');
    load(matname.name);
    %exclude backwards bouts
    heading_lim = 90; 
    %identify bouts during daylight
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);

    atk_angles = PropBoutAlignedHeading(day,31) - PropBoutAlignedPitch(day,31);
    posture_chg = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);

    %fit 1 degree-of-freedom sigmoid
    atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
    locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))
    posX8 = -1.11; %Mean across ages of 4dof sigmoid fits for (A(2)) when one_nth=8;
    one_nth = 8; %constrain sigmoid to point at 1/8th height
    sigfunc = @(A,x)(locY+ (atk_max)./(1 + exp(-A*(x- (A*posX8+log(-(locY-(one_nth-1)*atk_max)/(locY+atk_max)))/A ))));
    A0 = 1; % Initial value for solver               
    
    %solve best-fit sigmoid
    [A_fit, resnorm, R, ~, ~, ~, J] = lsqcurvefit(sigfunc,A0,posture_chg,atk_angles);
    A_fit_CI = nlparci(A_fit,R,'jacobian',J,'alpha',0.05);

    %sigmoid maximal slope
    slope_1dof_clutch(clutch_F2) = atk_max*A_fit(1)/4;      

    %clutch attack angles
    mean_atk_angle_clutch(clutch_F2) = mean(atk_angles);
    
    %clutch deviation from horizontal
    [day,~]=lightdarksplit(GrabbedTimes);
    mean_dev_horz(clutch_F2) = mean(abs(BodyAngles(day)));
       
    cd ..
end

for age_F2=1:4
    %plot attack angle vs. sigmoid maximal slope by clutch
    subplot(3,5,12); hold on
    plot(slope_1dof_clutch((age_F2-1)*4+[1:4]), mean_atk_angle_clutch((age_F2-1)*4+[1:4]),'.','color',colors_F2{age_F2})
    %plot deviation from horizontal vs. sigmoid maximal slope by clutch    
    subplot(3,5,13); hold on
    plot(slope_1dof_clutch((age_F2-1)*4+[1:4]), mean_dev_horz((age_F2-1)*4+[1:4]),'.','color',colors_F2{age_F2})
end

%fit attack angle vs. sigmoid maximal slope by clutch
subplot(3,5,12); hold on
tmp = polyfit(slope_1dof_clutch, mean_atk_angle_clutch, 1);
hold on; plot([0 13],polyval(tmp,[0 13]),'k-')
axis square; axis([0 13 -2 10]); xlabel('Fin-body ratio'); ylabel('Attack angle (deg)')
title(['Fig. 2E: r=' num2str(corr(slope_1dof_clutch', mean_atk_angle_clutch'),'%3.2f')])

%fit deviation from horizontal vs. sigmoid maximal slope by clutch    
subplot(3,5,13); hold on
tmp = polyfit(slope_1dof_clutch, mean_dev_horz, 1);
hold on; plot([0 13],polyval(tmp,[0 13]),'k-')
axis square; axis([0 13 7 17]); xlabel('Fin-body ratio'); ylabel('Deviation from horz (deg)')
title(['Fig. 2F: r=' num2str(corr(slope_1dof_clutch', mean_dev_horz'),'%3.2f')])

cd ..

%% Generate Figure 2 Supplement 2 - fin-tail coordination by clutch
figure('outerposition',[150 150 600 600]);
cd('Development_48hr')

d_F2S2 = dir;
isub_F2S2 = [d_F2S2(:).isdir]; 
nameFolds_F2S2 = {d_F2S2(isub_F2S2).name}';

% Iterate through folders corresponding to each clutch
for clutch_F2S2=1:(length(nameFolds_F2S2)-2)
    cd(nameFolds_F2S2{clutch_F2S2+2})  

    %load data
    matname=dir('*mat');
    load(matname.name);

    heading_lim = 90; 
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);

    %bin attack angle vs posture change data
    [xout,yout,~,ysd] = makeEvenHistogram(PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28), PropBoutAlignedHeading(day,31)-PropBoutAlignedPitch(day,31),11);
    %plot binned empirical data
    subplot(4,4,clutch_F2S2);
    plot(xout,yout); hold on;       
    axis square; axis([-8 8 -12 28])   

    edges = -18:4:18; centers=edges(1:end-1)+diff(edges(1:2))/2;

    atk_angles = PropBoutAlignedHeading(day,31) - PropBoutAlignedPitch(day,31);
    posture_chg = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);

    thresh = prctile(posture_chg,95);

    A0 = [1 -1 -0.2 20]; %// Initial values fed into solver
    % sigmoid function
    sigfunc = @(A,x)(A(3)+ (A(4))./(1 + exp(-A(1)*(x- (A(1)*A(2)+log(-(A(3)-(7)*A(4))/(A(3)+A(4))))/A(1) ))));
    %solve
    [A_fit, resnorm, R, ~, ~, ~, J] = lsqcurvefit(sigfunc,A0,posture_chg,atk_angles); %,[-inf -10 -inf],[inf 10 inf]);
    A_fit_CI = nlparci(A_fit,R,'jacobian',J,'alpha',0.05);
    %goodness of fit
    rsqq(clutch_F2S2) = 1-resnorm/sum((atk_angles-mean(atk_angles)).^2);
    %sigmoid steepness and maximal slope
    steepness(clutch_F2S2) = A_fit(1);
    steepness_hi(clutch_F2S2) = A_fit_CI(1,2);
    steepness_low(clutch_F2S2) = A_fit_CI(1,1);        
    slope(clutch_F2S2) = A_fit(4)*A_fit(1)/4;
    slopeHi(clutch_F2S2) = A_fit(4)*A_fit_CI(1,1)/4;
    slopeLow(clutch_F2S2) = A_fit(4)*A_fit_CI(1,2)/4;         

    mean_atk_angle(clutch_F2S2) = mean(atk_angles);

    %calculate fin bias ratio
    alpha_hat(clutch_F2S2) = slope(clutch_F2S2)/(1+slope(clutch_F2S2));
    alpha_hat_hi(clutch_F2S2) = slopeHi(clutch_F2S2)/(1+slopeHi(clutch_F2S2));
    alpha_hat_low(clutch_F2S2) = slopeLow(clutch_F2S2)/(1+slopeLow(clutch_F2S2));

    %Plot
    if clutch_F2S2==1
        title(['Fig2 Supp2: 04d, a = ' num2str(alpha_hat(clutch_F2S2),'%3.2f')])
    elseif clutch_F2S2<5
        title(['04d, a = ' num2str(alpha_hat(clutch_F2S2),'%3.2f')])
    elseif clutch_F2S2<9
        title(['07d, a = ' num2str(alpha_hat(clutch_F2S2),'%3.2f')])
    elseif clutch_F2S2<13
        title(['14d, a = ' num2str(alpha_hat(clutch_F2S2),'%3.2f')])
    else
        title(['21d, a = ' num2str(alpha_hat(clutch_F2S2),'%3.2f')])
        xlabel('Posture change (deg)')
    end

    %plot best-fit sigmoid
    subplot(4,4,clutch_F2S2);
    hold on; plot(-20:0.2:20, sigfunc(A_fit, -20:0.2:20));
    axis square; axis([-8 8 -12 28])

    cd ..
end
for i=[1 5 9 13]
    subplot(4,4,i); ylabel('Atk angle (deg)');
end
cd ..

%% Generate Figure 3 - fin-tail coordination in otog-/- mutants and controls
% Run in Raw_Data_Processed

sigmoid_dof = 2;
bootstrap_on = 1; %switch: 1 to calculate and plot bootstrapped confidence intervals on sigmoid fit, 0 to abstain
num_strap = 1000; %number of bootstrapping iterations
axis_size = [-3 10 -8 17]; %for plotting sigmoids

figure;
for groupFolder_otog=[1 2]
    nameFolds_otog = {'OtogControl','OtogMutant'};
    cd(nameFolds_otog{groupFolder_otog}) 

    heading_lim = 90; 
    matname=dir('*mat');
    load(matname.name);
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
    [xout,yout,~,ysd] = makeEvenHistogram(PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28), PropBoutAlignedHeading(day,31)-PropBoutAlignedPitch(day,31),24);%20); %100

    subplot(3,3,(groupFolder_otog-1)*3+1);
    plot(xout,yout); hold on; %plot(xout,yout+ysd); plot(xout,yout-ysd);       
    axis square; axis(axis_size)   

    edges = -18:4:18; centers=edges(1:end-1)+diff(edges(1:2))/2;
    
    attack_angle = PropBoutAlignedHeading(day,31) - PropBoutAlignedPitch(day,31);
    body_rotations = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);
    
    thresh = prctile(body_rotations,95);
    mean(attack_angle(body_rotations>thresh));
    
    corr(attack_angle, body_rotations);

    atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
    locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))
    posX10 = -1.3665; %Mean across ages of 4dof sigmoid fits for (A(2)) when one_nth=10;
    posX20 = -2.1353; %Mean across ages of 4dof sigmoid fits for (A(2)) when one_nth=20;
    posX8 = -1.11; %Mean across ages of 4dof sigmoid fits for (A(2)) when one_nth=8;
    posX12 = -1.5693;
    posX6 = -0.7662;
    
    if sigmoid_dof == 3
        sigfunc = @(A,x)(A(3) + (atk_max)./(1 + exp(-A(1)*(x-A(2)))));    
        A0 = [100 0 0]; %// Initial values fed into the iterative algorithm
    elseif sigmoid_dof == 2
        sigfunc = @(A,x)(locY + (atk_max)./(1 + exp(-A(1)*(x-A(2)))));    
        A0 = [1 0]; %// Initial values fed into the iterative algorithm        
    elseif sigmoid_dof == 1
        %constrain to (-0.6727,0) from mean across ages of xAtYeq0
        one_nth = 8;
        posXn = posX8;
        sigfunc = @(A,x)(locY+ (atk_max)./(1 + exp(-A*(x- (A*posXn+log(-(locY-(one_nth-1)*atk_max)/(locY+atk_max)))/A ))));
        A0 = 1; %// Initial values fed into the solver      
    else
        A0 = [1 -1 -0.2 20]; %// Initial values fed into the iterative algorithm
        one_nth = 8;
        sigfunc = @(A,x)(A(3)+ (A(4))./(1 + exp(-A(1)*(x- (A(1)*A(2)+log(-(A(3)-(one_nth-1)*A(4))/(A(3)+A(4))))/A(1) ))));
    end
    
    if bootstrap_on == 1
        clear sig_med sig_hi sig_low bootstrapped_fit
        sig_x = -20:0.01:40;
        for strap = 1:num_strap
           inds = randi(length(body_rotations),length(body_rotations),1);
           A_fit = lsqcurvefit(sigfunc, A0, body_rotations(inds), attack_angle(inds), [-inf -10 -inf], [inf 10 inf]);
           bootstrapped_fit(strap, :) = sigfunc(A_fit, sig_x);        
        end
        sig_mean = mean(bootstrapped_fit);
        sig_sd = std(bootstrapped_fit);
        sig_hi = sig_mean+sig_sd;
        sig_low = sig_mean-sig_sd;
    end
    
    [A_fit, resnorm, R, ~, ~, ~, J] = lsqcurvefit(sigfunc,A0,body_rotations,attack_angle); %,[-inf -10 -inf],[inf 10 inf]);
    A_fit_CI = nlparci(A_fit,R,'jacobian',J,'alpha',0.05);
 
    rsqq(groupFolder_otog) = 1-resnorm/sum((attack_angle-mean(attack_angle)).^2);

    if sigmoid_dof ~= 4
        slope_otog(groupFolder_otog) = atk_max*A_fit(1)/4;
        slopeLow_otog(groupFolder_otog) = atk_max*A_fit_CI(1,1)/4;
        slopeHi_otog(groupFolder_otog) = atk_max*A_fit_CI(1,2)/4;
    else
        steepness(groupFolder_otog) = A_fit(1);
        steepness_hi(groupFolder_otog) = A_fit_CI(1,2);
        steepness_low(groupFolder_otog) = A_fit_CI(1,1);        
        slope_otog(groupFolder_otog) = A_fit(4)*A_fit(1)/4;
        slopeHi_otog(groupFolder_otog) = A_fit(4)*A_fit_CI(1,1)/4;
        slopeLow_otog(groupFolder_otog) = A_fit(4)*A_fit_CI(1,2)/4;        
        height(groupFolder_otog) = A_fit(4);
        height_hi(groupFolder_otog) = A_fit_CI(4,2);
        height_low(groupFolder_otog) = A_fit_CI(4,1);
        posY(groupFolder_otog) = A_fit(3);
        posY_hi(groupFolder_otog) = A_fit_CI(3,2);
        posY_low(groupFolder_otog) = A_fit_CI(3,1);        
        posX(groupFolder_otog) = A_fit(2);        
        posX_hi(groupFolder_otog) = A_fit_CI(2,2);
        posX_low(groupFolder_otog) = A_fit_CI(2,1);            
        
        YatPosX(groupFolder_otog) = sigfunc(A_fit, A_fit(2));
        
        xAtYeq0(groupFolder_otog) = -(log(-A_fit(4)/A_fit(3)-1)/A_fit(1))-A_fit(2);
    end
    
    mean_atk_angle(groupFolder_otog) = mean(attack_angle);
    
    alpha_hat(groupFolder_otog) = slope_otog(groupFolder_otog)/(1+slope_otog(groupFolder_otog));
    alpha_hat_hi(groupFolder_otog) = slopeHi_otog(groupFolder_otog)/(1+slopeHi_otog(groupFolder_otog));
    alpha_hat_low(groupFolder_otog) = slopeLow_otog(groupFolder_otog)/(1+slopeLow_otog(groupFolder_otog));
    title([nameFolds_otog{groupFolder_otog} '; fin bias = ' num2str(alpha_hat(groupFolder_otog))])

    subplot(3,3,(groupFolder_otog-1)*3+1);
    hold on; plot(-20:0.2:20, sigfunc(A_fit, -20:0.2:20),'k');
    if bootstrap_on==1
        plot(sig_x, sig_low, 'k');
        plot(sig_x, sig_hi, 'k');
    end
    axis square; axis(axis_size)
    ylabel('Attack angle (deg)'); xlabel('Posture change (deg)');
    
    [day,~]=lightdarksplit(GrabbedTimes);
    meanAbspitch_clutch(groupFolder_otog) = mean(abs(BodyAngles(day)));
    meanPitch_clutch(groupFolder_otog) = mean(BodyAngles(day));
    
    edges = -90:0.25:90;
    centers = edges(1:end-1) + (edges(2)-edges(1))/2;
    counts=histc(body_rotations,edges);
    subplot(3,3,(groupFolder_otog-1)*3+2); plot(centers,counts(1:end-1)./sum(counts))
    xlabel('Posture change (deg)'); ylabel('Probability')
    axis square; xlim([-3 10]); ylim([0 0.3])

    edges = -90:1:90;
    centers = edges(1:end-1) + (edges(2)-edges(1))/2;
    counts=histc(attack_angle,edges);
    subplot(3,3,(groupFolder_otog-1)*3+3); plot(centers,counts(1:end-1)./sum(counts))
    xlabel('Attack angle (deg)'); ylabel('Probability')
    axis square; xlim([-8 17]); ylim([0 0.3]);
       
    %iterate by clutch
    d_cl = dir;
    isub_cl = [d_cl(:).isdir]; %# returns logical vector
    nameFolds_cl_otog = {d_cl(isub_cl).name}';
    for clutch_num = 1:5 
        cd(nameFolds_cl_otog{clutch_num+2})  
        matname_cl=dir('*mat');
        load(matname_cl.name);
        %Calculate median posture change during bouts (Figure 3D)
        [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
        body_rotations = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);
        clutch_body_rots(groupFolder_otog,clutch_num) = median(body_rotations);                
        %Calculate deviation from horizontal during steep climbs (Figure 3E)
        climb_min = 20;
        climb_deviation(groupFolder_otog,clutch_num) = mean(abs(PropBoutAlignedPitch(day(find(PropBoutAlignedHeading(day,31)>climb_min)),31)));        
        
        cd ..
    end

    cd ..
end

subplot(3,3,7); errorbar([1 2], slope_otog, slope_otog-slopeLow_otog, slopeHi_otog-slope_otog);
axis([0.8 2.2 -0.2 1.4]); axis square
ylabel('sigmoid slope'); xlabel('control         otog-/-')

subplot(3,3,8); for i=1:5; hold on; plot([1 2], clutch_body_rots(:,i),'.-','color',[.7 .7 .7]); end
plot([1 2],mean(clutch_body_rots'),'o-k')
ylabel('Posture change (deg)'); xlabel('control         otog-/-')
axis square; axis([0.8 2.2 -0.12 0.5])

subplot(3,3,9); for i=1:5; hold on; plot([1 2], climb_deviation(:,i),'.-','color',[.7 .7 .7]); end
plot([1 2],mean(climb_deviation'),'o-k')
ylabel('Deviation from horizontal (deg)'); xlabel('control         otog-/-')
axis square; axis([0.8 2.2 20 40])


%% Generate Figure 4 - Behavior following Purkinje cell lesions
% switches and parameters
sigmoid_dof = 1; %degrees of freedom for sigmoid fit
bootstrap_on = 1; %switch: 1 to calculate and plot bootstrapped confidence intervals on sigmoid fit, 0 to abstain
bootstrap_iter = 1000; %number of bootstrapping iterations
axis_size_CB = [-8 9 -11.38 21.62]; %for plotting sigmoids

figure('units','normalized','outerposition',[0 0 1 1]); %initialize figure

nameFolds_CB = {'CerebellarLesionControl','CerebellarLesion'}; %folders for loading data

clear slope slopeLow slopeHi slope_dn slopeLow_dn slopeHi_dn
        
for groupFolderCB=[1 2]
    cd(nameFolds_CB{groupFolderCB}) 

    heading_lim = 90; %ignore backwards swim bouts
    matname=dir('*mat');
    load(matname.name);
    
    %identify forwards swim bouts during circadian day
    [day,~]=lightdarksplit(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
    
    %calculate attack angles and posture changes
    atk_angles_CB = PropBoutAlignedHeading(day,31) - PropBoutAlignedPitch(day,31);
    posture_chg_CB = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);
    %bin and plot attack angles and posture changes for plotting
    [xout,yout,~,ysd] = makeEvenHistogram(posture_chg_CB, atk_angles_CB,15);
    subplot(3,4,4*groupFolderCB);
    plot(xout,yout); hold on; %plot(xout,yout+ysd); plot(xout,yout-ysd);       
    axis square; axis(axis_size)       
    
    % Parameters for sigmoid fits
    atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
    locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))
    posX8 = -1.11; %Mean across ages of 4dof sigmoid fits for (A(2))
    
    if sigmoid_dof == 3
        sigfunc = @(A,x)(A(3) + (atk_max)./(1 + exp(-A(1)*(x-A(2)))));    
        A0 = [100 0 0]; %// Initial values fed into the iterative algorithm
    elseif sigmoid_dof == 2
        sigfunc = @(A,x)(locY + (atk_max)./(1 + exp(-A(1)*(x-A(2)))));    
        A0 = [1 0]; %// Initial values fed into the iterative algorithm        
    elseif sigmoid_dof == 1
        %constrain to (-0.6727,0) from mean across ages of xAtYeq0
        one_nth = 8;
        posXn = posX8;
        sigfunc = @(A,x)(locY+ (atk_max)./(1 + exp(-A*(x- (A*posXn+log(-(locY-(one_nth-1)*atk_max)/(locY+atk_max)))/A ))));
        A0 = 1; %// Initial values for solver       
    else
        A0 = [1 -1 -0.2 20]; %// Initial values for solver
        one_nth = 8;
        sigfunc = @(A,x)(A(3)+ (A(4))./(1 + exp(-A(1)*(x- (A(1)*A(2)+log(-(A(3)-(one_nth-1)*A(4))/(A(3)+A(4))))/A(1) ))));
    end
    
    if bootstrap_on == 1
        clear sig_med sig_hi sig_low
        sig_x = -20:0.01:40; %abcissa values for plotting fit sigmoids
        for strap = 1:bootstrap_iter
           inds = randi(length(posture_chg_CB),length(posture_chg_CB),1); %random indices
           A_fit = lsqcurvefit(sigfunc, A0, posture_chg_CB(inds), atk_angles_CB(inds), [-inf -10 -inf], [inf 10 inf]); %solve for best-fit sigmoid with resampled data
           bootstrapped_fit(strap, :) = sigfunc(A_fit, sig_x); %append resampled sigmoid fit
           
           strap_atk_angles = atk_angles_CB(inds);
           strap_post_chg = posture_chg_CB(inds);
           body_rot_min = 1; %threshold for defining tail-mediated climb or dive
           %calculate proportion of conflicting and synergistic climbs for resampled data
           strap_nosedn_atk(strap, groupFolderCB) = sum(strap_atk_angles(strap_post_chg<-body_rot_min)>-1.59)./length(strap_atk_angles(strap_post_chg<-body_rot_min));
           strap_noseup_atk(strap, groupFolderCB) = sum(strap_atk_angles(strap_post_chg>body_rot_min)>-1.59)./length(strap_atk_angles(strap_post_chg>body_rot_min));
        end
        sig_mean = mean(bootstrapped_fit);
        sig_sd = std(bootstrapped_fit);
        sig_hi = sig_mean+sig_sd;
        sig_low = sig_mean-sig_sd;
    end
    
    %solve for best-fit sigmoid
    [A_fit, resnorm, R, ~, ~, ~, J] = lsqcurvefit(sigfunc,A0,posture_chg_CB,atk_angles_CB);
    A_fit_CI = nlparci(A_fit,R,'jacobian',J,'alpha',0.05); %calculate 95% confidence intervals
    steepness(groupFolderCB) = A_fit(1);
    %goodness-of-fit
    rsqq(groupFolderCB) = 1-resnorm/sum((atk_angles_CB-mean(atk_angles_CB)).^2);

    % fit nose-down activated fin use
    subplot(3,4,(groupFolderCB-1)*4+1); hold on;
    plot(xout,yout); hold on; %plot(xout,yout+ysd); plot(xout,yout-ysd);       
    axis square; axis(axis_size_CB)
    one_nth = 8; 

    %Fit double sigmoid
    sigfunc_aldoca = @(A,x)( A(4) + ((atk_max)./(1 + exp(-A(1)*(x- A(3))))) + ...
           ((A(2)*atk_max)./(1 + exp(-A(1)*(-x-A(3)))))   );
    A0_aldoca = [1 0.5 0 -5]; %// Initial values for solver    
    [A_fit_aldoca, resnorm_aldoca, R_aldoca, ~, ~, ~, J_aldoca] = lsqcurvefit(sigfunc_aldoca,A0_aldoca,posture_chg_CB,atk_angles_CB);
    A_fit_CI_aldoca = nlparci(A_fit_aldoca,R_aldoca,'jacobian',J_aldoca,'alpha',0.05);
    %To calculate ratio of amplitude of nose-down and nose-up lobes: A_fit_aldoca(2)
    %Goodness-of-fit
    rsqq_aldoca(groupFolderCB) = 1-resnorm_aldoca/sum((atk_angles_CB-mean(atk_angles_CB)).^2);
    aldocafits{groupFolderCB}=A_fit_aldoca;
    aldocafits_CI{groupFolderCB}=A_fit_CI_aldoca;
    hold on; plot(-20:0.2:20, sigfunc_aldoca(A_fit_aldoca, -20:0.2:20),'b');

    %calculate bootstrapped standard deviation of best-fit sigmoid
    if bootstrap_on == 1
        clear bootstrapped_fit
        for strap = 1:bootstrap_iter
           inds = randi(length(posture_chg_CB),length(posture_chg_CB),1);
           A_fit_aldoca = lsqcurvefit(sigfunc_aldoca, A0_aldoca, posture_chg_CB(inds), atk_angles_CB(inds)); %, [-inf 0.01 -inf],[inf inf inf]);          
           bootstrapped_fit(strap, :) = sigfunc_aldoca(A_fit_aldoca, sig_x); 
        end
        sig_mean_aldoca = mean(bootstrapped_fit);
        sig_sd_aldoca = std(bootstrapped_fit);
        sig_hi_aldoca = sig_mean_aldoca+sig_sd_aldoca;
        sig_low_aldoca = sig_mean_aldoca-sig_sd_aldoca;
        plot(sig_x, sig_low_aldoca, 'r');
        plot(sig_x, sig_hi_aldoca, 'r');
    end        

    %Calculate best-fit sigmoid properties
    if sigmoid_dof ~= 4
        slope(groupFolderCB) = atk_max*aldocafits{groupFolderCB}(1)/4;
        slopeLow(groupFolderCB) = atk_max*aldocafits_CI{groupFolderCB}(1,1)/4;
        slopeHi(groupFolderCB) = atk_max*aldocafits_CI{groupFolderCB}(1,2)/4;
        
        slope_dn(groupFolderCB) = atk_max*aldocafits{groupFolderCB}(1)*aldocafits{groupFolderCB}(2)/4;
        slopeLow_dn(groupFolderCB) = atk_max*aldocafits_CI{groupFolderCB}(1,1)*aldocafits_CI{groupFolderCB}(2,1)/4;
        slopeHi_dn(groupFolderCB) = atk_max*aldocafits_CI{groupFolderCB}(1,2)*aldocafits_CI{groupFolderCB}(2,2)/4;
    else
        steepness(groupFolderCB) = A_fit(1);
        steepness_hi(groupFolderCB) = A_fit_CI(1,2);
        steepness_low(groupFolderCB) = A_fit_CI(1,1);        
        slope(groupFolderCB) = A_fit(4)*A_fit(1)/4;
        slopeHi(groupFolderCB) = A_fit(4)*A_fit_CI(1,1)/4;
        slopeLow(groupFolderCB) = A_fit(4)*A_fit_CI(1,2)/4;        
        height(groupFolderCB) = A_fit(4);
        height_hi(groupFolderCB) = A_fit_CI(4,2);
        height_low(groupFolderCB) = A_fit_CI(4,1);
        posY(groupFolderCB) = A_fit(3);
        posY_hi(groupFolderCB) = A_fit_CI(3,2);
        posY_low(groupFolderCB) = A_fit_CI(3,1);        
        posX(groupFolderCB) = A_fit(2);        
        posX_hi(groupFolderCB) = A_fit_CI(2,2);
        posX_low(groupFolderCB) = A_fit_CI(2,1);            
        
        YatPosX(groupFolderCB) = sigfunc(A_fit, A_fit(2));
        xAtYeq0(groupFolderCB) = -(log(-A_fit(4)/A_fit(3)-1)/A_fit(1))-A_fit(2);
    end
    
    %calculate fin bias
    alpha_hat(groupFolderCB) = slope(groupFolderCB)/(1+slope(groupFolderCB));
    alpha_hat_hi(groupFolderCB) = slopeHi(groupFolderCB)/(1+slopeHi(groupFolderCB));
    alpha_hat_low(groupFolderCB) = slopeLow(groupFolderCB)/(1+slopeLow(groupFolderCB));

    %plot best-fit single sigmoids
    subplot(3,4,groupFolderCB*4);
    hold on; plot(-20:0.2:20, sigfunc(A_fit, -20:0.2:20));
    if bootstrap_on==1
        plot(sig_x, sig_low, 'g');
        plot(sig_x, sig_hi, 'g');
    end
    axis square; axis(axis_size_CB)
        
    %plot histograms for Fig.4A marignals
    heading_lim = 90; %exclude backwards bouts
    [day,~]=lightdarksplit_Inclusive(PropBoutAlignedTime); day = day(PropBoutAlignedHeading(day,31)<heading_lim & PropBoutAlignedHeading(day,31)>-heading_lim);
    atk_angles_CB = PropBoutAlignedHeading(day,31)-PropBoutAlignedPitch(day,31);
    posture_chg_CB = PropBoutAlignedPitch(day,30) - PropBoutAlignedPitch(day,28);
    %attack angle histograms
    edges=-98:2.75:100; centers=edges(1:end-1)+diff(edges(1:2))/2;
    counts = histc(atk_angles_CB,edges)/length(atk_angles_CB);
    subplot(3,4,(groupFolderCB-1)*4+2); plot(counts(1:end-1), centers); axis([0 0.5 -11.38 21.62]); %16.12]);
    %posture change histograms
    edges = -88:2:92; centers=edges(1:end-1)+diff(edges(1:2))/2;
    counts = histc(posture_chg_CB,edges)/length(posture_chg_CB);
    subplot(3,4,(groupFolderCB-1)*4+3); plot(centers,counts(1:end-1)); axis([-8 9 0 0.5])
    
    cd ..
end

%plot Fig. 4B, probability of conflicting swims
subplot(3,4,9); hold on; ylabel('prob. atk angle>0 & posture chg<-1deg'); title('Figure 4B')
errorbar([1 2], [mean(strap_nosedn_atk(:,1)) mean(strap_nosedn_atk(:,2))], [mean(strap_nosedn_atk(:,1)) mean(strap_nosedn_atk(:,2))]-[prctile(strap_nosedn_atk(:,1),2.5) prctile(strap_nosedn_atk(:,2),2.5)], [prctile(strap_nosedn_atk(:,1),97.5) prctile(strap_nosedn_atk(:,2),97.5)]-[mean(strap_nosedn_atk(:,1)) mean(strap_nosedn_atk(:,2))]);
axis([0.8 2.2 0.3 0.9]); xlabel('control     lesion'); axis square
%plot Fig. 4C, probability of synergistic swims
subplot(3,4,10); hold on; ylabel('prob. atk angle>0 & posture chg>1deg'); title('Figure 4C')
errorbar([1 2], [mean(strap_noseup_atk(:,1)) mean(strap_noseup_atk(:,2))], [mean(strap_noseup_atk(:,1)) mean(strap_noseup_atk(:,2))]-[prctile(strap_noseup_atk(:,1),2.5) prctile(strap_noseup_atk(:,2),2.5)], [prctile(strap_noseup_atk(:,1),97.5) prctile(strap_noseup_atk(:,2),97.5)]-[mean(strap_noseup_atk(:,1)) mean(strap_noseup_atk(:,2))]);
axis([0.8 2.2 0.3 0.9]); xlabel('control     lesion'); axis square
%plot Fig. 4D, maximum slope of nose-down lobe of double sigmoid
subplot(3,4,11); ylabel('slope of nose-down lobe'); xlabel('control     lesion'); title('Figure 4D')
hold on; errorbar([1 2],slope_dn, slope_dn-slopeLow_dn, slopeHi_dn-slope_dn);      
axis([0.8 2.2 -2 12]); axis square
%plot Fig. 4E, maximum slope of nose-up lobe of double sigmoid
subplot(3,4,12); ylabel('slope of nose-up lobe'); xlabel('control     lesion'); title('Figure 4E')
hold on; errorbar([1 2],slope, slope-slopeLow, slopeHi-slope);      
axis([0.8 2.2 -2 12]); axis square

%add labels
subplot(3,4,1); title('Fig 4A: Control fit w/ double sigmoid')
ylabel('Attack angle (deg)'); xlabel('Posture change (deg)');
subplot(3,4,2); title('Fig 4A: Control attack angle marginal'); axis square
ylabel('Attack angle (deg)'); xlabel('Probability');
subplot(3,4,3); title('Fig 4A: Control posture change marginal'); axis square
xlabel('Posture change (deg)'); ylabel('Probability');
subplot(3,4,4); title('Control fit w/ sigmoid for comparison')
ylabel('Attack angle (deg)'); xlabel('Posture change (deg)');
subplot(3,4,5); title('Fig 4A: Lesioned fit w/ double sigmoid')
ylabel('Attack angle (deg)'); xlabel('Posture change (deg)');
subplot(3,4,6); title('Fig 4A: Lesioned attack angle marginal'); axis square
ylabel('Attack angle (deg)'); xlabel('Probability');
subplot(3,4,7); title('Fig 4A: Lesioned posture change marginal'); axis square
xlabel('Posture change (deg)'); ylabel('Probability');
subplot(3,4,8); title('Lesioned fit w/ sigmoid for comparison')
ylabel('Attack angle (deg)'); xlabel('Posture change (deg)');


%% Generate Appendix figure 1 - simulated control system
figure;

% Constrain sigmoid for amplitude of posture change
up_steer = 13.1536; %0.05 percentile of posture changes concatenated from all ages
down_steer = -16.9815; %99.95 percentile of posture changes concatenated from all ages
body_span = up_steer - down_steer; %amplitude of posture change physical transfer sigmoid

% Coordination sigmoid parameters from 1dof fit
atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))

% Generate physical transformation sigmoids
sigfunc = @(A,x)(A(3) + (A(4))./(1 + exp(-A(1)*(x+A(2)))));   

%horizontal location of fin and body physical transfer functions
horz_offset_fin = (-atk_max/4)*log(-(atk_max+locY)/locY);
horz_offset_body = (-body_span/4)*log(-(body_span+down_steer)/(down_steer));
%algebraically from 0 = down_fin + fin_span/(1+exp(-4*horz_offset/fin_span)); %x=0, y=0, solve for horz_offset

% Plot physical transfer functions
%for tail
tmp=sigfunc([4/body_span; horz_offset_body; down_steer; body_span],-30:0.1:30);
subplot(2,3,1); hold on
plot(-30:0.1:30, tmp);
plot([0 0],[-20 20],':'); plot([-30 30],[0 0],':')
axis square; axis([-30 30 -30 30])
ylabel('body rotation (deg)'); xlabel('body rotation command (deg)')
%for fins
tmp = sigfunc([4/atk_max; horz_offset_fin; locY; atk_max], -30:0.1:30);                                       
subplot(2,3,2); hold on
plot(-30:0.1:30, tmp)
plot([0 0],[-20 20],':'); plot([-30 30],[0 0],':')
axis square; axis([-30 30 -30 30]); 
ylabel('attack angle (deg)'); xlabel('fin command (deg)')

subplot(2,3,3);
%Appendix Figure 1B
%plot empirical fin biases calculated from confidence intervals on maximal
%1 degree-of-freedom sigmoid slopes
errorbar([4 7 14 21], emp_fin_bias, emp_fin_bias-emp_fin_bias_Low, emp_fin_bias_Hi-emp_fin_bias);
axis square; axis([0 25 0.7 0.95]); ylabel('fin bias'); xlabel('age (dpf)'); title('Fig. A1B')

% Appendix Figure 1C
% Simulate swimming to calculate attack angle vs. posture change
% Parameters
% fin biases from 1dof sigmoid fits at 1, 2, and 3 wpf
fin_biases = [0, 0.74, 0.88, 0.92];
numIterations = 10000; %number of larvae to simulate; 100,000 for paper
numTargetsInSequence = 1; %number of randomly generated targets the larva must reach
bout_disp = 1.267; %in mm, averaged across all bouts from 4-21 dpf
traj_sd = 20.6726; %standard deviation of observed trajectories
traj_mean = 9.5145; %mean of observed trajectories
target_distances = 25; % distance of targets in mm

% Constrain sigmoid for amplitude of posture change
up_steer = 13.1536; %0.05 percentile of posture changes concatenated from all ages
down_steer = -16.9815; %99.95 percentile of posture changes concatenated from all ages
body_span = up_steer - down_steer; %amplitude of posture change physical transfer sigmoid

% Coordination sigmoid parameters from 1dof fit
atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))

% Generate physical transformation sigmoids
sigfunc = @(A,x)(A(3) + (A(4))./(1 + exp(-A(1)*(x+A(2)))));   

%horizontal location of fin and body physical transfer functions
horz_offset_fin = (-atk_max/4)*log(-(atk_max+locY)/locY);
horz_offset_body = (-body_span/4)*log(-(body_span+down_steer)/(down_steer));
%algebraically from 0 = down_fin + fin_span/(1+exp(-4*horz_offset/fin_span)); %x=0, y=0, solve for horz_offset

% Define noise terms
posture_chg_noise = 0; %error in body rotation
atk_angle_noise = 0; %error in attack angle generation
final_traj_noise = 11.3635; %externally-generated noise, standard deviaton of attack angles of finless 21dpf larvae

% Simulate swimming
hhh = waitbar(0,'model iteration');
for target_distance_index = 1:length(target_distances)
    target_distance = target_distances(target_distance_index);
       
    for fin_bias_index = 1:length(fin_biases)
        waitbar(((target_distance_index-1)*length(fin_biases)+fin_bias_index) / (length(fin_biases)*length(target_distances)), hhh,'Simulating with variable fin bias')
        sim_fin_bias = fin_biases(fin_bias_index); %fin bias for this iteration
    
        %initialize variables to store body- and fin-mediated steering, and resulting attack angles
        all_fin_steer = [];
        all_posture_chg = [];
        all_atk_angles = [];
        allPitches = []; %pitch-axis posture across all simulations
        clear x z all_x all_z final_z integrated_abs_z modelIEIs meanPitch all_atk_angles_iter mean_pitch_iter
        clear sdPitch counts_Pitch lag5corr bouts_to_target
        
        x = cell(numIterations,1); %initialize array for horizontal positions
        z = cell(numIterations,1); %initialize array for depth
        pitch_cells = cell(numIterations,1); %initialize array for pitch-axis postures

        for modelIteration = 1:numIterations
            % Initialize variables for appending swim properties
            steering_rotation = []; %commanded body rotation
            posture_chg = []; %resulting body rotation
            fin_skew = []; %commanded fin contribution to attack angle
            actual_skew = []; %resulting fin contribution to attack angle
            atk_angle = []; %total attack angle, including external forces
            pre_bout_pitch = []; %pitch-axis posture before the bout
            totalCommand = []; %angle from pre_bout_pitch to target before swim bout

            %initialize posture at horizontal
            Pitch = zeros(1);           
   
            %initialize bout displacements
            Bout_translation_x = []; Bout_translation_z = [];
            bout_trajectory = [];
            %initialize larva position
            x{modelIteration} = 0;
            z{modelIteration} = 0;

            % The simulation advances time-steps using a while loop.
            t=1; % 't' is the bout index.
            
            targetsAttained = 0; %initialize number of targets reached
            while targetsAttained < numTargetsInSequence                  
                target_direction = abs(normrnd(0,traj_sd));
                %exclude targets behind larva
                if target_direction>90; target_direction = 90; elseif target_direction<-90; target_direction = -90; end

                %target position in Cartesian coordinates
                target_x = x{modelIteration}(end) + target_distance * cosd(target_direction);
                target_z = z{modelIteration}(end) + target_distance * sind(target_direction);

                % advance until larva comes within 99% of distance to target
                while abs(x{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_x) || abs(z{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_z); % || abs(z{modelIteration}(end)) < abs(target_z);                               
                    t = t+1;
                    % Posture carries over from last bout. No passive rotation due to external forces.
                    Pitch(t) = Pitch(t-1);       
                    % limit pitches to +/- 180 deg
                    if Pitch(t) < -180
                        Pitch(t) = Pitch(t) + 360;
                    elseif Pitch(t) > 180
                        Pitch(t) = Pitch(t) -360;
                    end

                    % if larva passed target horizontally, simulate free turn around
                    if x{modelIteration}(end) > target_x
                        x{modelIteration}(end) = x{modelIteration}(end) - 2*(x{modelIteration}(end) - target_x);
                    end

                    % angle to target
                    target_traj(modelIteration,t) = atand((target_z - z{modelIteration}(end))/(target_x - x{modelIteration}(end)));
                    % magnitude of steering command to fins and tail
                    totalCommand(end+1) = abs(target_traj(modelIteration,t) - Pitch(t));
                    
                    % compute posture change during bout
                    % command to tail, scaled by fin bias
                    steering_command = (1-sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % physical rotation by tail due to command
                    steering_rotation(end+1) = sigfunc([4/body_span; horz_offset_body; down_steer; body_span], steering_command);
                    % add noise
                    posture_chg(end+1) = steering_rotation(end) + normrnd(0, posture_chg_noise);
                    % append
                    all_posture_chg(end+1) = steering_rotation(end);

                    % compute fin-mediated steering, scaled by fin bias
                    fin_command = (sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % change in bout trajectory due to command
                    fin_skew(end+1) = sigfunc([4/atk_max; horz_offset_fin; locY; atk_max], fin_command);                                       
                    % add noise
                    actual_skew(end+1) = fin_skew(end) + normrnd(0,atk_angle_noise);
                    % append
                    all_fin_steer(end+1) = actual_skew(end);
                    
                    % Execute commanded bout
                    % append pre-bout posture
                    pre_bout_pitch(end+1) = Pitch(t);
                    % rotate body
                    Pitch(t) = Pitch(t) + posture_chg(end);
                    %combine steering mechanisms and noise to compute bout trajectory 
                    bout_trajectory(end+1) = Pitch(t) + actual_skew(end) + normrnd(0,final_traj_noise);
                    %actual attack angle, including external forces
                    atk_angle(end+1) = bout_trajectory(end)-Pitch(t);
                    % append
                    all_atk_angles(end+1) = atk_angle(end);

                    %positional changes due to bout
                    Bout_translation_x(end+1) = bout_disp * cosd(bout_trajectory(end));
                    Bout_translation_z(end+1) = bout_disp * sind(bout_trajectory(end));

                    %new position
                    x{modelIteration}(end+1) = x{modelIteration}(end) + Bout_translation_x(end);
                    z{modelIteration}(end+1) = z{modelIteration}(end) + Bout_translation_z(end);           
                end
                
                %when while loop ends, target is reached
                targetsAttained = targetsAttained+1;
            end
            
            %append all positions and postures of the simulated larva
            all_x(modelIteration,1:length(x{modelIteration})) = x{modelIteration};
            all_z(modelIteration,1:length(z{modelIteration})) = z{modelIteration};
            pitch_cells{modelIteration} = Pitch;
            allPitches = [allPitches Pitch];
            %append attack angles and deviation from horizontal of simulated larva
            all_atk_angles_iter(modelIteration) = mean(atk_angle);
            mean_deviation_horz(modelIteration) = mean(abs(Pitch));

            %append steering variables
            steers_by_bout(modelIteration, 1:length(steering_rotation)) = steering_rotation;
            skews_by_bout(modelIteration, 1:length(atk_angle)) = atk_angle;
        end  
        
        % Plot simulated alpha curves
        [xout,yout,~,ysd] = makeEvenHistogram(all_posture_chg, all_atk_angles, 100); %1000 for paper
        subplot(2,3,4); hold on; 
        plot(xout,yout); 
    end
end       
close(hhh) %waitbar

subplot(2,3,4)
axis square; axis([-2 10 -4 16])
ylabel('Attack angle (deg)'); xlabel('Posture change (deg)'); title('Fig. A1C')
legend('alpha=0','1wpf','2wpf','3wpf')

%Figure A1D - Attack and vs. fin bias
fin_biases = 0:0.05:1;
% Simulate swimming
hhh = waitbar(0,'model iteration');
for target_distance_index = 1:length(target_distances)
    target_distance = target_distances(target_distance_index);
       
    for fin_bias_index = 1:length(fin_biases)
        waitbar(((target_distance_index-1)*length(fin_biases)+fin_bias_index) / (length(fin_biases)*length(target_distances)), hhh,'Simulating with variable fin bias')
        sim_fin_bias = fin_biases(fin_bias_index); %fin bias for this iteration
    
        %initialize variables to store body- and fin-mediated steering, and resulting attack angles
        all_fin_steer = [];
        all_posture_chg = [];
        all_atk_angles = [];
        allPitches = []; %pitch-axis posture across all simulations
        clear x z all_x all_z final_z integrated_abs_z modelIEIs meanPitch all_atk_angles_iter mean_pitch_iter
        clear sdPitch counts_Pitch lag5corr bouts_to_target
        
        x = cell(numIterations,1); %initialize array for horizontal positions
        z = cell(numIterations,1); %initialize array for depth
        pitch_cells = cell(numIterations,1); %initialize array for pitch-axis postures

        for modelIteration = 1:numIterations
            % Initialize variables for appending swim properties
            steering_rotation = []; %commanded body rotation
            posture_chg = []; %resulting body rotation
            fin_skew = []; %commanded fin contribution to attack angle
            actual_skew = []; %resulting fin contribution to attack angle
            atk_angle = []; %total attack angle, including external forces
            pre_bout_pitch = []; %pitch-axis posture before the bout
            totalCommand = []; %angle from pre_bout_pitch to target before swim bout

            %initialize posture at horizontal
            Pitch = zeros(1);           
   
            %initialize bout displacements
            Bout_translation_x = []; Bout_translation_z = [];
            bout_trajectory = [];
            %initialize larva position
            x{modelIteration} = 0;
            z{modelIteration} = 0;

            % The simulation advances time-steps using a while loop.
            t=1; % 't' is the bout index.
            
            targetsAttained = 0; %initialize number of targets reached
            while targetsAttained < numTargetsInSequence                  
                target_direction = abs(normrnd(0,traj_sd));
                %exclude targets behind larva
                if target_direction>90; target_direction = 90; elseif target_direction<-90; target_direction = -90; end

                %target position in Cartesian coordinates
                target_x = x{modelIteration}(end) + target_distance * cosd(target_direction);
                target_z = z{modelIteration}(end) + target_distance * sind(target_direction);

                % advance until larva comes within 99% of distance to target
                while abs(x{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_x) || abs(z{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_z); % || abs(z{modelIteration}(end)) < abs(target_z);                               
                    t = t+1;
                    % Posture carries over from last bout. No passive rotation due to external forces.
                    Pitch(t) = Pitch(t-1);       
                    % limit pitches to +/- 180 deg
                    if Pitch(t) < -180
                        Pitch(t) = Pitch(t) + 360;
                    elseif Pitch(t) > 180
                        Pitch(t) = Pitch(t) -360;
                    end

                    % if larva passed target horizontally, simulate free turn around
                    if x{modelIteration}(end) > target_x
                        x{modelIteration}(end) = x{modelIteration}(end) - 2*(x{modelIteration}(end) - target_x);
                    end

                    % angle to target
                    target_traj(modelIteration,t) = atand((target_z - z{modelIteration}(end))/(target_x - x{modelIteration}(end)));
                    % magnitude of steering command to fins and tail
                    totalCommand(end+1) = abs(target_traj(modelIteration,t) - Pitch(t));
                    
                    % compute posture change during bout
                    % command to tail, scaled by fin bias
                    steering_command = (1-sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % physical rotation by tail due to command
                    steering_rotation(end+1) = sigfunc([4/body_span; horz_offset_body; down_steer; body_span], steering_command);
                    % add noise
                    posture_chg(end+1) = steering_rotation(end) + normrnd(0, posture_chg_noise);
                    % append
                    all_posture_chg(end+1) = steering_rotation(end);

                    % compute fin-mediated steering, scaled by fin bias
                    fin_command = (sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % change in bout trajectory due to command
                    fin_skew(end+1) = sigfunc([4/atk_max; horz_offset_fin; locY; atk_max], fin_command);                                       
                    % add noise
                    actual_skew(end+1) = fin_skew(end) + normrnd(0,atk_angle_noise);
                    % append
                    all_fin_steer(end+1) = actual_skew(end);
                    
                    % Execute commanded bout
                    % append pre-bout posture
                    pre_bout_pitch(end+1) = Pitch(t);
                    % rotate body
                    Pitch(t) = Pitch(t) + posture_chg(end);
                    %combine steering mechanisms and noise to compute bout trajectory 
                    bout_trajectory(end+1) = Pitch(t) + actual_skew(end) + normrnd(0,final_traj_noise);
                    %actual attack angle, including external forces
                    atk_angle(end+1) = bout_trajectory(end)-Pitch(t);
                    % append
                    all_atk_angles(end+1) = atk_angle(end);

                    %positional changes due to bout
                    Bout_translation_x(end+1) = bout_disp * cosd(bout_trajectory(end));
                    Bout_translation_z(end+1) = bout_disp * sind(bout_trajectory(end));

                    %new position
                    x{modelIteration}(end+1) = x{modelIteration}(end) + Bout_translation_x(end);
                    z{modelIteration}(end+1) = z{modelIteration}(end) + Bout_translation_z(end);           
                end
                
                %when while loop ends, target is reached
                targetsAttained = targetsAttained+1;
            end
            
            %append all positions and postures of the simulated larva
            all_x(modelIteration,1:length(x{modelIteration})) = x{modelIteration};
            all_z(modelIteration,1:length(z{modelIteration})) = z{modelIteration};
            pitch_cells{modelIteration} = Pitch;
            allPitches = [allPitches Pitch];
            %append attack angles and deviation from horizontal of simulated larva
            all_atk_angles_iter(modelIteration) = mean(atk_angle);
            mean_deviation_horz(modelIteration) = mean(abs(Pitch));

            %append steering variables
            steers_by_bout(modelIteration, 1:length(steering_rotation)) = steering_rotation;
            skews_by_bout(modelIteration, 1:length(atk_angle)) = atk_angle;
        end
        avg_attack_angle(fin_bias_index) = mean(all_atk_angles);
    end
end       
close(hhh) %waitbar

subplot(2,3,5)
plot(slope_1dof_clutch./(1+slope_1dof_clutch), mean_atk_angle_clutch, '.k')
hold on; plot(fin_biases, avg_attack_angle,'r-')
axis square; axis([0.55 0.95 -1 10])
ylabel('Attack angle (deg)'); xlabel('Fin bias')
legend('empirical','sim')


%% Generate Appendix figure 2 - cost functions for otpimizing fin-tail coordination
figure('units','normalized','outerposition',[0 0 0.6 0.6]); %initialize figure

%Figure A2A: simulated trajectories
% Simulate swimming to calculate attack angle vs. posture change
% Parameters: fin biases from 1dof sigmoid fits at 1, 2, and 3 wpf
fin_biases = [0, 0.74, 0.92, 1];
numIterations = 1000; %number of larvae to simulate; 100,000 for paper
numTargetsInSequence = 1; %number of randomly generated targets the larva must reach
bout_disp = 1.267; %in mm, averaged across all bouts from 4-21 dpf
traj_sd = 20.6726; %standard deviation of observed trajectories
traj_mean = 9.5145; %mean of observed trajectories
target_distances = 25; % distance of targets in mm

% Constrain sigmoid for amplitude of posture change
up_steer = 13.1536; %0.05 percentile of posture changes concatenated from all ages
down_steer = -16.9815; %99.95 percentile of posture changes concatenated from all ages
body_span = up_steer - down_steer; %amplitude of posture change physical transfer sigmoid

% Coordination sigmoid parameters from 1dof fit
atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))

% Generate physical transformation sigmoids
sigfunc = @(A,x)(A(3) + (A(4))./(1 + exp(-A(1)*(x+A(2)))));   

%horizontal location of fin and body physical transfer functions
horz_offset_fin = (-atk_max/4)*log(-(atk_max+locY)/locY);
horz_offset_body = (-body_span/4)*log(-(body_span+down_steer)/(down_steer));
%algebraically from 0 = down_fin + fin_span/(1+exp(-4*horz_offset/fin_span)); %x=0, y=0, solve for horz_offset

% Define noise terms
posture_chg_noise = 0; %error in body rotation
atk_angle_noise = 0; %error in attack angle generation
final_traj_noise = 0; %no externally-generated noise

%same distribution of target directions for all fin biases
load('target_direction_set_ES19.mat')

% Simulate swimming
hhh = waitbar(0,'model iteration');
for target_distance_index = 1:length(target_distances)
    target_distance = target_distances(target_distance_index);
       
    for fin_bias_index = 1:length(fin_biases)
        waitbar(((target_distance_index-1)*length(fin_biases)+fin_bias_index) / (length(fin_biases)*length(target_distances)), hhh,'Simulating with variable fin bias')
        sim_fin_bias = fin_biases(fin_bias_index); %fin bias for this iteration
    
        %initialize variables to store body- and fin-mediated steering, and resulting attack angles
        all_fin_steer = [];
        all_posture_chg = [];
        all_atk_angles = [];
        allPitches = []; %pitch-axis posture across all simulations
        clear x z all_x all_z final_z integrated_abs_z modelIEIs meanPitch all_atk_angles_iter mean_pitch_iter
        clear sdPitch counts_Pitch lag5corr bouts_to_target
        
        x = cell(numIterations,1); %initialize array for horizontal positions
        z = cell(numIterations,1); %initialize array for depth
        pitch_cells = cell(numIterations,1); %initialize array for pitch-axis postures

        for modelIteration = 1:numIterations
            % Initialize variables for appending swim properties
            steering_rotation = []; %commanded body rotation
            posture_chg = []; %resulting body rotation
            fin_skew = []; %commanded fin contribution to attack angle
            actual_skew = []; %resulting fin contribution to attack angle
            atk_angle = []; %total attack angle, including external forces
            pre_bout_pitch = []; %pitch-axis posture before the bout
            totalCommand = []; %angle from pre_bout_pitch to target before swim bout

            %initialize posture at horizontal
            Pitch = zeros(1);           
   
            %initialize bout displacements
            Bout_translation_x = []; Bout_translation_z = [];
            bout_trajectory = [];
            %initialize larva position
            x{modelIteration} = 0;
            z{modelIteration} = 0;

            % The simulation advances time-steps using a while loop.
            t=1; % 't' is the bout index.
            
            targetsAttained = 0; %initialize number of targets reached
            while targetsAttained < numTargetsInSequence                  
                target_direction = target_direction_set(modelIteration);
                %exclude targets behind larva
                if target_direction>90; target_direction = 90; elseif target_direction<-90; target_direction = -90; end

                %target position in Cartesian coordinates
                target_x = x{modelIteration}(end) + target_distance * cosd(target_direction);
                target_z = z{modelIteration}(end) + target_distance * sind(target_direction);

                % advance until larva comes within 99% of distance to target
                while abs(x{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_x) || abs(z{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_z); % || abs(z{modelIteration}(end)) < abs(target_z);                               
                    t = t+1;
                    % Posture carries over from last bout. No passive rotation due to external forces.
                    Pitch(t) = Pitch(t-1);       
                    % limit pitches to +/- 180 deg
                    if Pitch(t) < -180
                        Pitch(t) = Pitch(t) + 360;
                    elseif Pitch(t) > 180
                        Pitch(t) = Pitch(t) -360;
                    end

                    % if larva passed target horizontally, simulate free turn around
                    if x{modelIteration}(end) > target_x
                        x{modelIteration}(end) = x{modelIteration}(end) - 2*(x{modelIteration}(end) - target_x);
                    end

                    % angle to target
                    target_traj(modelIteration,t) = atand((target_z - z{modelIteration}(end))/(target_x - x{modelIteration}(end)));
                    % magnitude of steering command to fins and tail
                    totalCommand(end+1) = abs(target_traj(modelIteration,t) - Pitch(t));
                    
                    % compute posture change during bout
                    % command to tail, scaled by fin bias
                    steering_command = (1-sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % physical rotation by tail due to command
                    steering_rotation(end+1) = sigfunc([4/body_span; horz_offset_body; down_steer; body_span], steering_command);
                    % add noise
                    posture_chg(end+1) = steering_rotation(end) + normrnd(0, posture_chg_noise);
                    % append
                    all_posture_chg(end+1) = steering_rotation(end);

                    % compute fin-mediated steering, scaled by fin bias
                    fin_command = (sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % change in bout trajectory due to command
                    fin_skew(end+1) = sigfunc([4/atk_max; horz_offset_fin; locY; atk_max], fin_command);                                       
                    % add noise
                    actual_skew(end+1) = fin_skew(end) + normrnd(0,atk_angle_noise);
                    % append
                    all_fin_steer(end+1) = actual_skew(end);
                    
                    % Execute commanded bout
                    % append pre-bout posture
                    pre_bout_pitch(end+1) = Pitch(t);
                    % rotate body
                    Pitch(t) = Pitch(t) + posture_chg(end);
                    %combine steering mechanisms and noise to compute bout trajectory 
                    bout_trajectory(end+1) = Pitch(t) + actual_skew(end) + normrnd(0,final_traj_noise);
                    %actual attack angle, including external forces
                    atk_angle(end+1) = bout_trajectory(end)-Pitch(t);
                    % append
                    all_atk_angles(end+1) = atk_angle(end);

                    %positional changes due to bout
                    Bout_translation_x(end+1) = bout_disp * cosd(bout_trajectory(end));
                    Bout_translation_z(end+1) = bout_disp * sind(bout_trajectory(end));

                    %new position
                    x{modelIteration}(end+1) = x{modelIteration}(end) + Bout_translation_x(end);
                    z{modelIteration}(end+1) = z{modelIteration}(end) + Bout_translation_z(end);           
                end
                
                %when while loop ends, target is reached
                targetsAttained = targetsAttained+1;
            end
            
            %append all positions and postures of the simulated larva
            all_x(modelIteration,1:length(x{modelIteration})) = x{modelIteration};
            all_z(modelIteration,1:length(z{modelIteration})) = z{modelIteration};
            pitch_cells{modelIteration} = Pitch;
            allPitches = [allPitches Pitch];
            %append attack angles and deviation from horizontal of simulated larva
            all_atk_angles_iter(modelIteration) = mean(atk_angle);
            mean_deviation_horz(modelIteration) = mean(abs(Pitch));

            %append steering variables
            steers_by_bout(modelIteration, 1:length(steering_rotation)) = steering_rotation;
            skews_by_bout(modelIteration, 1:length(atk_angle)) = atk_angle;
        end  
        
        subplot(2, 4, fin_bias_index); hold on
        for i = 1:numIterations            
            plot(x{i}(1:6),z{i}(1:6),'Color',[.5 .5 .5]); plot(x{i}(1:6),z{i}(1:6),'k.','MarkerSize',10);
        end
        axis square; xlabel('horizontal pos. (mm)'); axis square; axis([-0.5 6.5 -1 6])
        title(['fin bias = ' num2str(fin_biases(fin_bias_index),'%3.2f')])
        
    end
end       
close(hhh) %waitbar
subplot(2,4,1); ylabel('vertical position (mm)')

%Figure A2B - A2E
%Please note, many iterations are required to precisely estimate cost
%functions, important for estimating minima. This code may take a long time to run.
% Parameters
fin_biases = 0:0.01:1;
numIterations = 100000; %number of larvae to simulate; 100000 for paper
numTargetsInSequence = 1; %number of randomly generated targets the larva must reach
bout_disp = 1.267; %in mm, averaged across all bouts from 4-21 dpf
traj_sd = 20.6726; %standard deviation of observed trajectories
traj_mean = 9.5145; %mean of observed trajectories
target_distances = 25; % distance of targets in mm

% Constrain sigmoid for amplitude of posture change
up_steer = 13.1536; %0.05 percentile of posture changes concatenated from all ages
down_steer = -16.9815; %99.95 percentile of posture changes concatenated from all ages
body_span = up_steer - down_steer; %amplitude of posture change physical transfer sigmoid

% Coordination sigmoid parameters from 1dof fit
atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))

% Generate physical transformation sigmoids
sigfunc = @(A,x)(A(3) + (A(4))./(1 + exp(-A(1)*(x+A(2)))));   

%horizontal location of fin and body physical transfer functions
horz_offset_fin = (-atk_max/4)*log(-(atk_max+locY)/locY);
horz_offset_body = (-body_span/4)*log(-(body_span+down_steer)/(down_steer));
%algebraically from 0 = down_fin + fin_span/(1+exp(-4*horz_offset/fin_span)); %x=0, y=0, solve for horz_offset

% Define noise terms
posture_chg_noise = 0; %error in body rotation
atk_angle_noise = 0; %error in attack angle generation
final_traj_noise = 11.3635; %externally-generated noise, standard deviaton of attack angles of finless 21dpf larvae

% Simulate swimming
hhh = waitbar(0,'model iteration');
for target_distance_index = 1:length(target_distances)
    target_distance = target_distances(target_distance_index);
       
    for fin_bias_index = 1:length(fin_biases)
        waitbar(((target_distance_index-1)*length(fin_biases)+fin_bias_index) / (length(fin_biases)*length(target_distances)), hhh)
        sim_fin_bias = fin_biases(fin_bias_index); %fin bias for this iteration
    
        %initialize variables to store body- and fin-mediated steering, and resulting attack angles
        all_fin_steer = [];
        all_posture_chg = [];
        all_atk_angles = [];
        allPitches = []; %pitch-axis posture across all simulations
        clear x z all_x all_z final_z integrated_abs_z modelIEIs meanPitch all_atk_angles_iter mean_pitch_iter
        clear sdPitch counts_Pitch lag5corr bouts_to_target
        clear sum_sq_steer_cmd
        
        x = cell(numIterations,1); %initialize array for horizontal positions
        z = cell(numIterations,1); %initialize array for depth
        pitch_cells = cell(numIterations,1); %initialize array for pitch-axis postures

        for modelIteration = 1:numIterations
            % Initialize variables for appending swim properties
            steering_rotation = []; %commanded body rotation
            posture_chg = []; %resulting body rotation
            fin_skew = []; %commanded fin contribution to attack angle
            actual_skew = []; %resulting fin contribution to attack angle
            atk_angle = []; %total attack angle, including external forces
            pre_bout_pitch = []; %pitch-axis posture before the bout
            totalCommand = []; %angle from pre_bout_pitch to target before swim bout
            
            %initialize posture at horizontal
            Pitch = zeros(1);           
   
            %initialize bout displacements
            Bout_translation_x = []; Bout_translation_z = [];
            bout_trajectory = [];
            %initialize larva position
            x{modelIteration} = 0;
            z{modelIteration} = 0;

            % The simulation advances time-steps using a while loop.
            t=1; % 't' is the bout index.

            targetsAttained = 0; %initialize number of targets reached
            while targetsAttained < numTargetsInSequence                         
                target_direction = abs(normrnd(0,traj_sd));
                %exclude targets behind larva
                if target_direction>90; target_direction = 90; elseif target_direction<-90; target_direction = -90; end

                %target position in Cartesian coordinates
                target_x = x{modelIteration}(end) + target_distance * cosd(target_direction);
                target_z = z{modelIteration}(end) + target_distance * sind(target_direction);

                % advance until larva comes within 99% of distance to target
                while abs(x{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_x) || abs(z{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_z); % || abs(z{modelIteration}(end)) < abs(target_z);                               
                    t = t+1;
                    % Posture carries over from last bout. No passive rotation due to external forces.
                    Pitch(t) = Pitch(t-1);       
                    % limit pitches to +/- 180 deg
                    if Pitch(t) < -180
                        Pitch(t) = Pitch(t) + 360;
                    elseif Pitch(t) > 180
                        Pitch(t) = Pitch(t) -360;
                    end

                    % if larva passed target horizontally, simulate free turn around
                    if x{modelIteration}(end) > target_x
                        x{modelIteration}(end) = x{modelIteration}(end) - 2*(x{modelIteration}(end) - target_x);
                    end

                    % angle to target
                    target_traj(modelIteration,t) = atand((target_z - z{modelIteration}(end))/(target_x - x{modelIteration}(end)));
                    % magnitude of steering command to fins and tail
                    totalCommand(end+1) = abs(target_traj(modelIteration,t) - Pitch(t));
                    
                    % compute posture change during bout
                    % command to tail, scaled by fin bias
                    steering_command = (1-sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % physical rotation by tail due to command
                    steering_rotation(end+1) = sigfunc([4/body_span; horz_offset_body; down_steer; body_span], steering_command);
                    % add noise
                    posture_chg(end+1) = steering_rotation(end) + normrnd(0, posture_chg_noise);
                    % append
                    all_posture_chg(end+1) = steering_rotation(end);

                    % compute fin-mediated steering, scaled by fin bias
                    fin_command = (sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % change in bout trajectory due to command
                    fin_skew(end+1) = sigfunc([4/atk_max; horz_offset_fin; locY; atk_max], fin_command);                                       
                    % add noise
                    actual_skew(end+1) = fin_skew(end) + normrnd(0,atk_angle_noise);
                    % append
                    all_fin_steer(end+1) = actual_skew(end);
                    
                    % Execute commanded bout
                    % append pre-bout posture
                    pre_bout_pitch(end+1) = Pitch(t);
                    % rotate body
                    Pitch(t) = Pitch(t) + posture_chg(end);
                    %combine steering mechanisms and noise to compute bout trajectory 
                    bout_trajectory(end+1) = Pitch(t) + actual_skew(end) + normrnd(0,final_traj_noise);
                    %actual attack angle, including external forces
                    atk_angle(end+1) = bout_trajectory(end)-Pitch(t);
                    % append
                    all_atk_angles(end+1) = atk_angle(end);

                    %positional changes due to bout
                    Bout_translation_x(end+1) = bout_disp * cosd(bout_trajectory(end));
                    Bout_translation_z(end+1) = bout_disp * sind(bout_trajectory(end));

                    %new position
                    x{modelIteration}(end+1) = x{modelIteration}(end) + Bout_translation_x(end);
                    z{modelIteration}(end+1) = z{modelIteration}(end) + Bout_translation_z(end);           
                end
                
                %when while loop ends, target is reached
                targetsAttained = targetsAttained+1;
            end
            
            %append all positions and postures of the simulated larva
            all_x(modelIteration,1:length(x{modelIteration})) = x{modelIteration};
            all_z(modelIteration,1:length(z{modelIteration})) = z{modelIteration};
            pitch_cells{modelIteration} = Pitch;
            allPitches = [allPitches Pitch];
            %append attack angles and deviation from horizontal of simulated larva
            all_atk_angles_iter(modelIteration) = mean(atk_angle);
            mean_deviation_horz(modelIteration) = mean(abs(Pitch));

            %append steering variables
            steers_by_bout(modelIteration, 1:length(steering_rotation)) = steering_rotation;
            skews_by_bout(modelIteration, 1:length(atk_angle)) = atk_angle;
            %append effort variables
            sum_sq_steer_cmd(modelIteration) = sum(totalCommand.^2);
        end
        
        %compute average attack angle across all simulated larvae at this fin bias
        avg_attack_angle(target_distance_index, fin_bias_index) = mean(all_atk_angles_iter);

        %compute average effort variables across all simulated larvae at this fin bias
        all_sum_sq_steer_cmd_median(target_distance_index, fin_bias_index) = median(sum_sq_steer_cmd);
        all_sum_sq_steer_cmd(target_distance_index, fin_bias_index) = mean(sum_sq_steer_cmd);
        
        %compute standard deviation and mean of deviation from horizontal across all simulated larvae at this fin bias
        sdPitch_ByParam(target_distance_index, fin_bias_index) = 180/pi* circ_std(pi/180*mean_deviation_horz');
        meanPitch_ByParam(target_distance_index, fin_bias_index) = 180/pi* circ_mean(abs(pi/180*mean_deviation_horz'));

        %calculate bootstrapped confidence intervals on effort and kinematic variables
        num_straps = 1000; %number of times to resample
        for strap=1:num_straps
            resample_pitch(strap) = 180/pi* circ_mean(abs(pi/180 * mean_deviation_horz(randi(length(mean_deviation_horz),length(mean_deviation_horz),1))'));
            resample_effort_sq_cmd(strap) = mean(sum_sq_steer_cmd(randi(length(sum_sq_steer_cmd),length(sum_sq_steer_cmd),1)));
        end
        %calculate 99% confidence intervals
        meanPitch_995(target_distance_index, fin_bias_index) = prctile(resample_pitch,99.5);
        meanPitch_005(target_distance_index, fin_bias_index) = prctile(resample_pitch,0.5);
        %effort terms
        resample_effort_sq_cmd_995(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_cmd,99.5);
        resample_effort_sq_cmd_005(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_cmd,0.5);
    end
end
close(hhh) %waitbar

% plot absolute devaition from horizontal vs fin bias
subplot(2,4,5); title('Fig. A2B'); hold on;
plot(slope_1dof_clutch./(1+slope_1dof_clutch), mean_dev_horz, 'k.')
plot(fin_biases, meanPitch_ByParam,'g-')
plot(fin_biases, meanPitch_005,'g-')
plot(fin_biases, meanPitch_995,'g-')
axis square; axis([0 1 0 20]); xlabel('fin bias'); ylabel('deviation from horz (deg)')
legend('devel.','sim')

% plot effort vs fin bias
subplot(2,4,6); title('Fig. A2C'); hold on;
plot(fin_biases, all_sum_sq_steer_cmd./max(all_sum_sq_steer_cmd), 'b')
plot(fin_biases, resample_effort_sq_cmd_005./max(all_sum_sq_steer_cmd), 'b')
plot(fin_biases, resample_effort_sq_cmd_995./max(all_sum_sq_steer_cmd), 'b')
axis square; axis([0 1 0 1]); xlabel('fin bias'); ylabel('Effort (norm.)')


% parameterize balance weight for defining cost function 
betas = 0:0.01:1;

% plot cost vs fin bias, with effort defined as sum of squared commands
%plot cost functions for parameterized beta (balance weight)
subplot(2,4,7); title('Fig. A2D'); hold on
hold on; mincost=[]; exceedlo=[]; exceedhi=[];
for i=1:length(betas) 
    %parameterize beta from 
    beta = betas(i); 
    cost= beta*(all_sum_sq_steer_cmd/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); 
    %compute cost confidence intervals
    costhi = beta*(resample_effort_sq_cmd_995/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_995/max(meanPitch_ByParam));
    costlo = beta*(resample_effort_sq_cmd_005/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_005/max(meanPitch_ByParam));
    %smooth cost functions
    smcost=smooth(cost,3); smcosthi=smooth(costhi,3); smcostlo=smooth(costlo,3);
    
    %find fin bias that minimizes cost
    mincost(i)=find(cost==min(cost));
    %calculate confidence intervals on fin bias that minimizes cost, by
    %finding fin bias at which cost function exceeds its confidence interval
    tmp = find(smcostlo(1:mincost(i)-1)>smcost(mincost(i)),1,'last'); 
    if isempty(tmp); tmp=0; end
    tmp2 = find(smcosthi(1:mincost(i)-1)<smcost(mincost(i)),1,'last'); 
    if isempty(tmp2); tmp2=0; end   
    exceedlo(i) = max(tmp,tmp2); %lower bound of CI
    tmp = find(smcostlo(mincost(i)+1:end)>smcost(mincost(i)),1,'first'); 
    if isempty(tmp); tmp=length(fin_biases); else tmp=tmp+mincost(i); end
    tmp2 = find(smcosthi(mincost(i)+1:end)<smcost(mincost(i)),1,'first'); 
    if isempty(tmp2); tmp2=length(fin_biases); else tmp2=tmp2+mincost(i); end
    exceedhi(i) = min(tmp,tmp2); %upper bound of CI
end
for beta=0:0.2:1
    cost= beta*(all_sum_sq_steer_cmd/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); 
    plot(fin_biases, cost, '-k');
end
axis square; axis([0 1 0 1])
xlabel('fin bias'); ylabel('Cost')

%plot fin bias that minimizes cost as a function of balance weight
subplot(2,4,8); title('Fig. A2E'); hold on;
plot(fliplr(fin_biases), fin_biases(mincost),'k')
%plot confidence intervals
try plot(fliplr(fin_biases), fin_biases(exceedlo+1),'color',[.5 .5 .5]); end
plot(fliplr(fin_biases), fin_biases(exceedhi),'color',[.5 .5 .5])
axis square; xlabel('beta, balance weight'); ylabel('fin bias that minimizes cost')
%plot horizontal lines at empirical fin biases
plot([0 1],[0.73 0.73],'r'); %7dpf
plot([0 1],[0.88 0.88],'r'); %14dpf
plot([0 1],[0.95 0.95]),'r'; %21dpf
axis([0 1 0 1]);


%% Generate Appendix figure 3 - simulations with varying definitions of effort
%Please note, many iterations are required to precisely estimate cost
%functions, important for estimating minima. This code may take a long time to run.

% Parameters
fin_biases = 0:0.01:1;
numIterations = 100000; %number of larvae to simulate
numTargetsInSequence = 1; %number of randomly generated targets the larva must reach
bout_disp = 1.267; %in mm, averaged across all bouts from 4-21 dpf
traj_sd = 20.6726; %standard deviation of observed trajectories
traj_mean = 9.5145; %mean of observed trajectories
target_distances = 25; % distance of targets in mm

% Constrain sigmoid for amplitude of posture change
up_steer = 13.1536; %0.05 percentile of posture changes concatenated from all ages
down_steer = -16.9815; %99.95 percentile of posture changes concatenated from all ages
body_span = up_steer - down_steer; %amplitude of posture change physical transfer sigmoid

% Coordination sigmoid parameters from 1dof fit
atk_max = 16.9779; %Mean across ages of 4dof sigmoid fits
locY = -2.9393; %Mean across ages of 4dof sigmoid fits for (A(3))

% Generate physical transformation sigmoids
sigfunc = @(A,x)(A(3) + (A(4))./(1 + exp(-A(1)*(x+A(2)))));   

%horizontal location of fin and body physical transfer functions
horz_offset_fin = (-atk_max/4)*log(-(atk_max+locY)/locY);
horz_offset_body = (-body_span/4)*log(-(body_span+down_steer)/(down_steer));
%algebraically from 0 = down_fin + fin_span/(1+exp(-4*horz_offset/fin_span)); %x=0, y=0, solve for horz_offset

% Define noise terms
posture_chg_noise = 0; %error in body rotation
atk_angle_noise = 0; %error in attack angle generation
final_traj_noise = 11.3635; %externally-generated noise, standard deviaton of attack angles of finless 21dpf larvae

% Simulate swimming
hhh = waitbar(0,'model iteration');
for target_distance_index = 1:length(target_distances)
    target_distance = target_distances(target_distance_index);
       
    for fin_bias_index = 1:length(fin_biases)
        waitbar(((target_distance_index-1)*length(fin_biases)+fin_bias_index) / (length(fin_biases)*length(target_distances)), hhh)
        sim_fin_bias = fin_biases(fin_bias_index); %fin bias for this iteration
    
        %initialize variables to store body- and fin-mediated steering, and resulting attack angles
        all_fin_steer = [];
        all_posture_chg = [];
        all_atk_angles = [];
        allPitches = []; %pitch-axis posture across all simulations
        clear x z all_x all_z final_z integrated_abs_z modelIEIs meanPitch all_atk_angles_iter mean_pitch_iter
        clear sdPitch counts_Pitch lag5corr bouts_to_target
        clear sum_sq_steer_cmd sum_sq_steer_force
        
        x = cell(numIterations,1); %initialize array for horizontal positions
        z = cell(numIterations,1); %initialize array for depth
        pitch_cells = cell(numIterations,1); %initialize array for pitch-axis postures

        for modelIteration = 1:numIterations
            % Initialize variables for appending swim properties
            steering_rotation = []; %commanded body rotation
            posture_chg = []; %resulting body rotation
            fin_skew = []; %commanded fin contribution to attack angle
            actual_skew = []; %resulting fin contribution to attack angle
            atk_angle = []; %total attack angle, including external forces
            pre_bout_pitch = []; %pitch-axis posture before the bout
            totalCommand = []; %angle from pre_bout_pitch to target before swim bout
            %variables to append command and kinematic variables for calculating effort
            all_sq_steer_force = []; all_abs_steer_force = [];
            all_sq_fin_force = []; all_abs_fin_force = [];
            all_sq_fin_cmd = []; all_abs_fin_cmd = [];

            %initialize posture at horizontal
            Pitch = zeros(1);           
   
            %initialize bout displacements
            Bout_translation_x = []; Bout_translation_z = [];
            bout_trajectory = [];
            %initialize larva position
            x{modelIteration} = 0;
            z{modelIteration} = 0;

            % The simulation advances time-steps using a while loop.
            t=1; % 't' is the bout index.

            targetsAttained = 0; %initialize number of targets reached
            while targetsAttained < numTargetsInSequence                         
                target_direction = abs(normrnd(0,traj_sd));
                %exclude targets behind larva
                if target_direction>90; target_direction = 90; elseif target_direction<-90; target_direction = -90; end

                %target position in Cartesian coordinates
                target_x = x{modelIteration}(end) + target_distance * cosd(target_direction);
                target_z = z{modelIteration}(end) + target_distance * sind(target_direction);

                % advance until larva comes within 99% of distance to target
                while abs(x{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_x) || abs(z{modelIteration}(end)) < (1-0.01/(1+targetsAttained))*abs(target_z); % || abs(z{modelIteration}(end)) < abs(target_z);                               
                    t = t+1;
                    % Posture carries over from last bout. No passive rotation due to external forces.
                    Pitch(t) = Pitch(t-1);       
                    % limit pitches to +/- 180 deg
                    if Pitch(t) < -180
                        Pitch(t) = Pitch(t) + 360;
                    elseif Pitch(t) > 180
                        Pitch(t) = Pitch(t) -360;
                    end

                    % if larva passed target horizontally, simulate free turn around
                    if x{modelIteration}(end) > target_x
                        x{modelIteration}(end) = x{modelIteration}(end) - 2*(x{modelIteration}(end) - target_x);
                    end

                    % angle to target
                    target_traj(modelIteration,t) = atand((target_z - z{modelIteration}(end))/(target_x - x{modelIteration}(end)));
                    % magnitude of steering command to fins and tail
                    totalCommand(end+1) = abs(target_traj(modelIteration,t) - Pitch(t));
                    
                    % compute posture change during bout
                    % command to tail, scaled by fin bias
                    steering_command = (1-sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % physical rotation by tail due to command
                    steering_rotation(end+1) = sigfunc([4/body_span; horz_offset_body; down_steer; body_span], steering_command);
                    % add noise
                    posture_chg(end+1) = steering_rotation(end) + normrnd(0, posture_chg_noise);
                    % append
                    all_posture_chg(end+1) = steering_rotation(end);

                    % compute fin-mediated steering, scaled by fin bias
                    fin_command = (sim_fin_bias)  * (target_traj(modelIteration,t) - Pitch(t));
                    % change in bout trajectory due to command
                    fin_skew(end+1) = sigfunc([4/atk_max; horz_offset_fin; locY; atk_max], fin_command);                                       
                    % add noise
                    actual_skew(end+1) = fin_skew(end) + normrnd(0,atk_angle_noise);
                    % append
                    all_fin_steer(end+1) = actual_skew(end);

                    %for computing effort from kinematic variables
                    %sum of absolute value of fin- and tail-mediated steering
                    all_abs_steer_force(end+1) = abs(sind(fin_skew(end)))/sind(atk_max)   +   abs(all_posture_chg(end))/(body_span/2);
                    %sum of squared fin- and tail-mediated steering                    
                    all_sq_steer_force(end+1) = (sind(fin_skew(end))/sind(atk_max))^2   +   (all_posture_chg(end)/(body_span/2))^2;
                    %absolute value of fin-mediated steering
                    all_sq_fin_force(end+1) = abs(sind(fin_skew(end)))/sind(atk_max);
                    %square of fin-mediated steering
                    all_abs_fin_force(end+1) = (sind(fin_skew(end))/sind(atk_max))^2;
                    %square of command to fins
                    all_sq_fin_cmd(end+1) = fin_command^2;
                    %absolute value of command to fins
                    all_abs_fin_cmd(end+1) = abs(fin_command);
                    
                    % Execute commanded bout
                    % append pre-bout posture
                    pre_bout_pitch(end+1) = Pitch(t);
                    % rotate body
                    Pitch(t) = Pitch(t) + posture_chg(end);
                    %combine steering mechanisms and noise to compute bout trajectory 
                    bout_trajectory(end+1) = Pitch(t) + actual_skew(end) + normrnd(0,final_traj_noise);
                    %actual attack angle, including external forces
                    atk_angle(end+1) = bout_trajectory(end)-Pitch(t);
                    % append
                    all_atk_angles(end+1) = atk_angle(end);

                    %positional changes due to bout
                    Bout_translation_x(end+1) = bout_disp * cosd(bout_trajectory(end));
                    Bout_translation_z(end+1) = bout_disp * sind(bout_trajectory(end));

                    %new position
                    x{modelIteration}(end+1) = x{modelIteration}(end) + Bout_translation_x(end);
                    z{modelIteration}(end+1) = z{modelIteration}(end) + Bout_translation_z(end);           
                end
                
                %when while loop ends, target is reached
                targetsAttained = targetsAttained+1;
            end
            
            %append all positions and postures of the simulated larva
            all_x(modelIteration,1:length(x{modelIteration})) = x{modelIteration};
            all_z(modelIteration,1:length(z{modelIteration})) = z{modelIteration};
            pitch_cells{modelIteration} = Pitch;
            allPitches = [allPitches Pitch];
            %append attack angles and deviation from horizontal of simulated larva
            all_atk_angles_iter(modelIteration) = mean(atk_angle);
            mean_deviation_horz(modelIteration) = mean(abs(Pitch));

            %append steering variables
            steers_by_bout(modelIteration, 1:length(steering_rotation)) = steering_rotation;
            skews_by_bout(modelIteration, 1:length(atk_angle)) = atk_angle;
            %append effort variables
            sum_sq_steer_cmd(modelIteration) = sum(totalCommand.^2);
            sum_abs_steer_cmd(modelIteration) = sum(totalCommand);
            sum_sq_steer_force(modelIteration) = sum(all_sq_steer_force);
            sum_abs_steer_force(modelIteration) = sum(all_abs_steer_force);
            sum_sq_fin_force(modelIteration) = sum(all_sq_fin_force);
            sum_abs_fin_force(modelIteration) = sum(all_abs_fin_force);
            sum_sq_fin_cmd(modelIteration) = sum(all_sq_fin_cmd);
            sum_abs_fin_cmd(modelIteration) = sum(all_abs_fin_cmd);
        end
        
        %compute average attack angle across all simulated larvae at this fin bias
        avg_attack_angle(target_distance_index, fin_bias_index) = mean(all_atk_angles_iter);

        %compute average effort variables across all simulated larvae at this fin bias
        all_sum_sq_steer_cmd_median(target_distance_index, fin_bias_index) = median(sum_sq_steer_cmd);
        all_sum_sq_force(target_distance_index, fin_bias_index) = median(sum_sq_steer_force);        
        all_sum_sq_steer_cmd(target_distance_index, fin_bias_index) = mean(sum_sq_steer_cmd);
        all_sum_abs_steer_cmd(target_distance_index, fin_bias_index) = mean(sum_abs_steer_cmd);
        all_sum_abs_steer_force(target_distance_index, fin_bias_index) = median(sum_abs_steer_force);
        all_sum_sq_fin_force(target_distance_index, fin_bias_index) = median(sum_sq_fin_force);
        all_sum_abs_fin_force(target_distance_index, fin_bias_index) = median(sum_abs_fin_force);
        all_sum_sq_fin_cmd(target_distance_index, fin_bias_index) = median(sum_sq_fin_cmd);
        all_sum_abs_fin_cmd(target_distance_index, fin_bias_index) = median(sum_abs_fin_cmd);
        
        %compute standard deviation and mean of deviation from horizontal across all simulated larvae at this fin bias
        sdPitch_ByParam(target_distance_index, fin_bias_index) = 180/pi* circ_std(pi/180*mean_deviation_horz');
        meanPitch_ByParam(target_distance_index, fin_bias_index) = 180/pi* circ_mean(abs(pi/180*mean_deviation_horz'));

        %calculate bootstrapped confidence intervals on effort and kinematic variables
        num_straps = 1000; %number of times to resample
        for strap=1:num_straps
            resample_pitch(strap) = 180/pi* circ_mean(abs(pi/180 * mean_deviation_horz(randi(length(mean_deviation_horz),length(mean_deviation_horz),1))'));
            resample_effort_sq_cmd(strap) = mean(sum_sq_steer_cmd(randi(length(sum_sq_steer_cmd),length(sum_sq_steer_cmd),1)));
            resample_effort_abs_cmd(strap) = mean(sum_abs_steer_cmd(randi(length(sum_abs_steer_cmd),length(sum_abs_steer_cmd),1)));
            resample_effort_sq_kinem(strap) = mean(sum_sq_steer_force(randi(length(sum_sq_steer_force),length(sum_sq_steer_force),1)));
            resample_effort_abs_kinem(strap) = mean(sum_abs_steer_force(randi(length(sum_abs_steer_force),length(sum_abs_steer_force),1)));            
            resample_atk(strap) = mean(all_atk_angles_iter(randi(length(all_atk_angles_iter),length(all_atk_angles_iter),1)));
            resample_effort_abs_fin_kinem(strap) = mean(sum_abs_fin_force(randi(length(sum_abs_fin_force),length(sum_abs_fin_force),1)));            
            resample_effort_sq_fin_kinem(strap) = mean(sum_sq_fin_force(randi(length(sum_sq_fin_force),length(sum_sq_fin_force),1)));            
            resample_effort_sq_fin_cmd(strap) = mean(sum_sq_fin_cmd(randi(length(sum_sq_fin_cmd),length(sum_sq_fin_cmd),1)));
            resample_effort_abs_fin_cmd(strap) = mean(sum_abs_fin_cmd(randi(length(sum_abs_fin_cmd),length(sum_abs_fin_cmd),1)));
        end
        %calculate 99% confidence intervals
        meanPitch_995(target_distance_index, fin_bias_index) = prctile(resample_pitch,99.5);
        meanPitch_005(target_distance_index, fin_bias_index) = prctile(resample_pitch,0.5);
        atk_995(target_distance_index, fin_bias_index) = prctile(resample_atk,99.5);
        atk_005(target_distance_index, fin_bias_index) = prctile(resample_atk,0.5);            
        %effort terms
        resample_effort_sq_cmd_995(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_cmd,99.5);
        resample_effort_sq_cmd_005(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_cmd,0.5);
        resample_effort_abs_cmd_995(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_cmd,99.5);
        resample_effort_abs_cmd_005(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_cmd,0.5);
        resample_effort_sq_kinem_995(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_kinem,99.5);
        resample_effort_sq_kinem_005(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_kinem,0.5);
        resample_effort_abs_kinem_995(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_kinem,99.5);
        resample_effort_abs_kinem_005(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_kinem,0.5);
        resample_effort_abs_fin_kinem_995(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_fin_kinem,99.5);
        resample_effort_abs_fin_kinem_005(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_fin_kinem,0.5);
        resample_effort_sq_fin_kinem_995(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_fin_kinem,99.5);
        resample_effort_sq_fin_kinem_005(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_fin_kinem,0.5);
        resample_effort_sq_fin_cmd_995(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_fin_cmd,99.5);
        resample_effort_sq_fin_cmd_005(target_distance_index, fin_bias_index) = prctile(resample_effort_sq_fin_cmd,0.5);
        resample_effort_abs_fin_cmd_995(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_fin_cmd,99.5);
        resample_effort_abs_fin_cmd_005(target_distance_index, fin_bias_index) = prctile(resample_effort_abs_fin_cmd,0.5);
    end
end
       
close(hhh) %waitbar

figure('units','normalized','outerposition',[0 0 1 1]); %initialize figure

% parameterize balance weight for defining cost function 
betas = 0:0.01:1;

% plot cost vs fin bias, with effort defined as sum of squared commands
subplot(2,4,1); hold on;
title('sum sq cmd')
hold on; mincost=[]; exceedlo=[]; exceedhi=[];
for i=1:length(betas) 
    %parameterize beta from 
    beta = betas(i); 
    cost= beta*(all_sum_sq_steer_cmd/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); 
    %compute cost confidence intervals
    costhi = beta*(resample_effort_sq_cmd_995/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_995/max(meanPitch_ByParam));
    costlo = beta*(resample_effort_sq_cmd_005/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_005/max(meanPitch_ByParam));
    %smooth cost functions
    smcost=smooth(cost,3); smcosthi=smooth(costhi,3); smcostlo=smooth(costlo,3);
    
    %find fin bias that minimizes cost
    mincost(i)=find(cost==min(cost));
    %calculate confidence intervals on fin bias that minimizes cost, by
    %finding fin bias at which cost function exceeds its confidence interval
    tmp = find(smcostlo(1:mincost(i)-1)>smcost(mincost(i)),1,'last'); 
    if isempty(tmp); tmp=0; end
    tmp2 = find(smcosthi(1:mincost(i)-1)<smcost(mincost(i)),1,'last'); 
    if isempty(tmp2); tmp2=0; end   
    exceedlo(i) = max(tmp,tmp2); %lower bound of CI
    tmp = find(smcostlo(mincost(i)+1:end)>smcost(mincost(i)),1,'first'); 
    if isempty(tmp); tmp=length(fin_biases); else tmp=tmp+mincost(i); end
    tmp2 = find(smcosthi(mincost(i)+1:end)<smcost(mincost(i)),1,'first'); 
    if isempty(tmp2); tmp2=length(fin_biases); else tmp2=tmp2+mincost(i); end
    exceedhi(i) = min(tmp,tmp2); %upper bound of CI
end
%plot cost functions for parameterized beta (balance weight)
for beta=0:0.05:1
    cost= beta*(all_sum_sq_steer_cmd/max(all_sum_sq_steer_cmd)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); 
    plot(fin_biases, cost, '-k');
end
axis square; axis([0 1 0 1])
xlabel('fin bias'); ylabel('cost')
%plot fin bias that minimizes cost as a function of balance weight
subplot(2,4,2); hold on;
plot(fliplr(fin_biases), fin_biases(mincost))
%plot confidence intervals
try plot(fliplr(fin_biases), fin_biases(exceedlo+1)); end
plot(fliplr(fin_biases), fin_biases(exceedhi))
axis square; xlabel('beta, balance weight'); ylabel('fin bias that minimizes cost')
%plot horizontal lines at empirical fin biases
plot([0 1],[0.73 0.73]); %7dpf
plot([0 1],[0.88 0.88]); %14dpf
plot([0 1],[0.95 0.95]); %21dpf
axis([0 1 0 1]);


%plot effort vs fin bias, with effort defined as sum of absolute commands
subplot(2,4,3); hold on;
title('Fig A3A: sum abs cmd')
hold on; mincost=[]; exceedlo=[]; exceedhi=[];
for i=1:length(betas) 
    %parameterize beta from 
    beta = betas(i); 
    
    cost= beta*(all_sum_abs_steer_cmd/max(all_sum_abs_steer_cmd)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); 
    %compute cost confidence intervals
    costhi=beta*(resample_effort_abs_cmd_995/max(all_sum_abs_steer_cmd)) + (1-beta)*(meanPitch_995/max(meanPitch_ByParam));
    costlo=beta*(resample_effort_abs_cmd_005/max(all_sum_abs_steer_cmd)) + (1-beta)*(meanPitch_005/max(meanPitch_ByParam));
    %smooth cost functions
    smcost=smooth(cost,3); smcosthi=smooth(costhi,3); smcostlo=smooth(costlo,3);
    
    %find fin bias that minimizes cost
    mincost(i)=find(cost==min(cost));
    %calculate confidence intervals on fin bias that minimizes cost, by
    %finding fin bias at which cost function exceeds its confidence interval
    tmp = find(smcostlo(1:mincost(i)-1)>smcost(mincost(i)),1,'last'); 
    if isempty(tmp); tmp=0; end
    tmp2 = find(smcosthi(1:mincost(i)-1)<smcost(mincost(i)),1,'last'); 
    if isempty(tmp2); tmp2=0; end   
    exceedlo(i) = max(tmp,tmp2); %lower bound of CI
    tmp = find(smcostlo(mincost(i)+1:end)>smcost(mincost(i)),1,'first'); 
    if isempty(tmp); tmp=length(fin_biases); else tmp=tmp+mincost(i); end
    tmp2 = find(smcosthi(mincost(i)+1:end)<smcost(mincost(i)),1,'first'); 
    if isempty(tmp2); tmp2=length(fin_biases); else tmp2=tmp2+mincost(i); end
    exceedhi(i) = min(tmp,tmp2); %upper bound of CI
end
%plot cost functions for parameterized beta (balance weight)
for beta=0:0.05:1
    cost= beta*(all_sum_abs_steer_cmd/max(all_sum_abs_steer_cmd)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam));     
    plot(fin_biases, cost, '-k');
end
axis square; axis([0 1 0 1])
xlabel('fin bias'); ylabel('cost')
%plot fin bias that minimizes cost as a function of balance weight
subplot(2,4,4); hold on;
plot(fliplr(fin_biases), fin_biases(mincost))
%plot confidence intervals
try plot(fliplr(fin_biases), fin_biases(exceedlo+1)); end
plot(fliplr(fin_biases), fin_biases(exceedhi))
axis square; xlabel('beta, balance weight'); ylabel('fin bias that minimizes cost')
%plot horizontal lines at empirical fin biases
plot([0 1],[0.73 0.73]); %7dpf
plot([0 1],[0.88 0.88]); %14dpf
plot([0 1],[0.95 0.95]); %21dpf
axis([0 1 0 1]);


%plot effort vs fin bias, with effort defined as sum of squared acceleration
subplot(2,4,5); hold on;
title('Fig A3C: sum sq accel')
hold on; mincost=[]; exceedlo=[]; exceedhi=[];
for i=1:length(betas) 
    %parameterize beta from 
    beta = betas(i); 
    
    cost= beta*(all_sum_sq_force/max(all_sum_sq_force)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); mincost(i)=find(cost==min(cost));
    %compute cost confidence intervals
    costhi=beta*(resample_effort_sq_kinem_995/max(all_sum_sq_force)) + (1-beta)*(meanPitch_995/max(meanPitch_ByParam));
    costlo=beta*(resample_effort_sq_kinem_005/max(all_sum_sq_force)) + (1-beta)*(meanPitch_005/max(meanPitch_ByParam));
    %smooth cost functions
    smcost=smooth(cost,3); smcosthi=smooth(costhi,3); smcostlo=smooth(costlo,3);
    
    %find fin bias that minimizes cost
    mincost(i)=find(cost==min(cost));
    %calculate confidence intervals on fin bias that minimizes cost, by
    %finding fin bias at which cost function exceeds its confidence interval
    tmp = find(smcostlo(1:mincost(i)-1)>smcost(mincost(i)),1,'last'); 
    if isempty(tmp); tmp=0; end
    tmp2 = find(smcosthi(1:mincost(i)-1)<smcost(mincost(i)),1,'last'); 
    if isempty(tmp2); tmp2=0; end   
    exceedlo(i) = max(tmp,tmp2); %lower bound of CI
    tmp = find(smcostlo(mincost(i)+1:end)>smcost(mincost(i)),1,'first'); 
    if isempty(tmp); tmp=length(fin_biases); else tmp=tmp+mincost(i); end
    tmp2 = find(smcosthi(mincost(i)+1:end)<smcost(mincost(i)),1,'first'); 
    if isempty(tmp2); tmp2=length(fin_biases); else tmp2=tmp2+mincost(i); end
    exceedhi(i) = min(tmp,tmp2); %upper bound of CI
end
%plot cost functions for parameterized beta (balance weight)
for beta=0:0.05:1
    cost= beta*(all_sum_sq_force/max(all_sum_sq_force)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam));
    plot(fin_biases, cost, '-k');
end
axis square; axis([0 1 0 1])
xlabel('fin bias'); ylabel('cost')
%plot fin bias that minimizes cost as a function of balance weight
subplot(2,4,6); hold on;
plot(fliplr(fin_biases), fin_biases(mincost))
%plot confidence intervals
try plot(fliplr(fin_biases), fin_biases(exceedlo+1)); end
plot(fliplr(fin_biases), fin_biases(exceedhi))
axis square; xlabel('beta, balance weight'); ylabel('fin bias that minimizes cost')
%plot horizontal lines at empirical fin biases
plot([0 1],[0.73 0.73]); %7dpf
plot([0 1],[0.88 0.88]); %14dpf
plot([0 1],[0.95 0.95]); %21dpf
axis([0 1 0 1]);


%plot effort vs fin bias, with effort defined as sum of absolute acceleration
subplot(2,4,7); hold on;
title('Fig A3E: sum abs accel')
hold on; mincost=[]; exceedlo=[]; exceedhi=[];
for i=1:length(betas) 
    %parameterize beta from 
    beta = betas(i); 
    
    cost= beta*(all_sum_abs_steer_force/max(all_sum_abs_steer_force)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam)); 
    %compute cost confidence intervals
    costhi=beta*(resample_effort_abs_kinem_995/max(all_sum_abs_steer_force)) + (1-beta)*(meanPitch_995/max(meanPitch_ByParam));
    costlo=beta*(resample_effort_abs_kinem_005/max(all_sum_abs_steer_force)) + (1-beta)*(meanPitch_005/max(meanPitch_ByParam));
    %smooth cost functions
    smcost=smooth(cost,3); smcosthi=smooth(costhi,3); smcostlo=smooth(costlo,3);
    
    %find fin bias that minimizes cost
    mincost(i)=find(cost==min(cost));
    %calculate confidence intervals on fin bias that minimizes cost, by
    %finding fin bias at which cost function exceeds its confidence interval
    tmp = find(smcostlo(1:mincost(i)-1)>smcost(mincost(i)),1,'last'); 
    if isempty(tmp); tmp=0; end
    tmp2 = find(smcosthi(1:mincost(i)-1)<smcost(mincost(i)),1,'last'); 
    if isempty(tmp2); tmp2=0; end   
    exceedlo(i) = max(tmp,tmp2); %lower bound of CI
    tmp = find(smcostlo(mincost(i)+1:end)>smcost(mincost(i)),1,'first'); 
    if isempty(tmp); tmp=length(fin_biases); else tmp=tmp+mincost(i); end
    tmp2 = find(smcosthi(mincost(i)+1:end)<smcost(mincost(i)),1,'first'); 
    if isempty(tmp2); tmp2=length(fin_biases); else tmp2=tmp2+mincost(i); end
    exceedhi(i) = min(tmp,tmp2); %upper bound of CI
end
%plot cost functions for parameterized beta (balance weight)
for beta=0:0.05:1
    cost= beta*(all_sum_abs_steer_force/max(all_sum_abs_steer_force)) + (1-beta)*(meanPitch_ByParam/max(meanPitch_ByParam));
    plot(fin_biases, cost, '-k');
end
axis square; axis([0 1 0 1])
xlabel('fin bias'); ylabel('cost')
%plot fin bias that minimizes cost as a function of balance weight
subplot(2,4,8); hold on;
plot(fliplr(fin_biases), fin_biases(mincost))
%plot confidence intervals
try plot(fliplr(fin_biases), fin_biases(exceedlo+1)); end
plot(fliplr(fin_biases), fin_biases(exceedhi))
axis square; xlabel('beta, balance weight'); ylabel('fin bias that minimizes cost')
%plot horizontal lines at empirical fin biases
plot([0 1],[0.73 0.73]); %7dpf
plot([0 1],[0.88 0.88]); %14dpf
plot([0 1],[0.95 0.95]); %21dpf
axis([0 1 0 1]);

